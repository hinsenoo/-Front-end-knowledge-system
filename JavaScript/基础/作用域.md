# 作用域

## 1. 基本概念

​		变量存储的地方，以及在需要时如何寻找他们。—— 解决这问题的规则称之为作用域。

### 1.1 编译原理

1. 传统编译语言：在执行前会经历三个步骤，统称为**编译**：

   - 分词/词法分析 ( Tokenizing/Lexing )：这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元 ( token )。例如：`var a = 2;` => `var、a、=、2、;`

   - 解析/语法分析 ( Parsing )：这个过程是将语法单元流 (数组) 转换成一个由元素主机嵌套所组成的代表了程序语法结构的树。这树被称为 “抽象语法树” ( **Abstract Syntax Tree**, **AST**)。

     ![1580540110249](assets/1580540110249.png)
     
     注：一个简单的AST，例如 var a = 2; a 为标识符(Identifier)，= 为赋值表达式，2 为数值。
     
   - 代码生成：将 **AST** 转换为可执行代码的过程被称为代码生成。简单来说就是有某种方法可以将 `var a = 2;` 的 AST 转换为一组机器指令，用来创建一个叫做 a 的变量(包括分配内存等)，将一个值储存在 a 中。
   
2.  JavaScript：大部分情况下编译发生在代码执行前的几微秒，并且更为复杂，通常在parsing和代码生成阶段，存在大量对运行性能的优化操作。

### 1.2 理解作用域

- 引擎：从头到尾复制整个 JavaScript 程序的编译及执行过程。
- 编译器：负责语法分析及代码生成的工作。
- 作用域：负责收集并维护所有声明的标识符(变量) 组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

例：`var a = 2;`

编译器：	

- 处理 `var a`，询问作用域是否存在 a。是则忽略该声明，继续进行编译；否则在当前作用域声明一个新的变量 a。
- 为引擎生成运行时所需的代码，用来处理赋值操作 ( `a = 2` )。

引擎：运行时询问当前作用域是否存在 a，是则使用该变量，否则继续查找(作用域链)，找到则进行赋值，否则抛出异常。

**变量查找：**作用域用来确定在何处以及如何查找变量(标识符)的规则。

- LHS——赋值操作的目标是谁(容器)，赋值操作的左侧进行 LHS 查询。

- RHS——谁是赋值操作的源头，赋值操作的非左侧进行 RHS 查询。

- 简单来说，如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

  例如：a = b; a 为 LHS 查询 (寻找目标 a)，b 为 RHS 查询（查询 b 变量的值）

### 1.3 作用域嵌套

​		一个函数或块级作用域嵌套在另一个函数或块级作用域中，当在当前作用域无法找到某个变量时，就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达最外层的作用域 (也就是全局作用域) 为止。

### 1.4 异常

​		不成功的 RHS 引用会导致抛出 **ReferenceError** 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量 ( 非严格模式下 )，严格模式下会抛出 **ReferenceError** 异常。如果找到该变量，但进行不合理操作，会抛出 **TypeError** 异常。

 

## 2. 词法作用域

### 2.1 基本概念

> 大部分编译器的第一个工作阶段叫做词法化（也叫单词化），词法化的过程中会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。——理解词法作用域的基础

​		**词法作用域就是定义在词法阶段的作用域。**换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。（存在一些欺骗词法作用域的方法）

### 2.2 查找

​		**作用域查找会在找到第一个匹配的标识符时停止，始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。**通过 window.标识符 可以访问被同名变量所遮蔽的全局变量，非全局变量被遮蔽则无法访问。

​		无论函数在**哪里**被调用，也无论它**如何**被调用，**它的词法作用域都只由函数被声明时所处的位置决定。**

### 2.3 欺骗词法(不推荐)

​		欺骗词法作用域会导致性能下降。在程序中动态生成代码的使用场景非常罕见，因为带来的好处无法抵消性能上的损失。

1. **eval**: 执行动态创建的代码

   ```js
   function foo(str, a){
       eval(str); // 欺骗！
       console.log(a, b);
   }
   var b = 2;
   foo("var b = 3;", 1); // 1,3
   ```

   注：严格模式下，eval 在运行时有自己的词法作用域，即其中中声明无法改变所在的作用域。

2. **with**：用于重复引用同一个对象中的多个属性的快捷方式。

   ```js
   function foo(obj) {
       with(obj) {
           a = 2;
       }
   }
   var o1 = { a: 3 };
   var o2 = { b: 3 };
   
   foo(o1);
   console.log( o1.a ); // 2
   
   foo(o2);
   console.log( o2.a ); // undefined
   console.log( a ); // 2 —— a 被泄漏到全局作用域上!
   ```

   解析： 在 with 块内部，对变量 a 实际上就是一个 **LHS** 引用，并将 2 赋值给它。with 把对象处理为一个**完全隔离的词法作用域**，这个对象的属性被处理为定义在这个作用域中的词法标识符(无法限制 var 声明)。

   - 当传递 o1 ，`a=2` 赋值操作找到了 o1.a 并将 2 赋值给它。
   - 当传递 o2，o2 并没有 a 属性，因此不会创建这个属性，o2.a 保持 undefined ，进行正常的 LHS ，自动创建了一个全局变量。

   **注：with 在严格模式下禁用。**

3. **性能**：

   - JavaScript 引擎会在编译阶段进行数项性能优化，部分优化依赖于能够根据代码词进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。
   - 如果出现了 eval 或 with，引擎只能简单的假设关于标识符位置的判断都是无效的，无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。
   - 使用这其中任何一个机制都将导致代码运行变慢。

