# 一、什么是拷贝？

举个例子：

```js
let arr = [1, 2, 3];
let newArr = arr;
newArr[0] = 100;

console.log(arr);//[100, 2, 3]
```

这是直接赋值的情况，不涉及任何拷贝。当改变 `newArr` 的时候，由于是同一个引用，`arr` 的指向的值也跟着改变。

现在进行浅拷贝:

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;

console.log(arr);//[1, 2, 3]
复制代码
```

当修改`newArr`的时候，arr的值并不改变。什么原因?因为这里`newArr`是`arr`浅拷贝后的结果，`newArr`和`arr`现在引用的已经不是同一块空间啦！

但是这又会带来一个潜在的问题:

```js
let arr = [1, 2, {val: 4}];
let newArr = arr.slice();
newArr[2].val = 1000;

console.log(arr);//[ 1, 2, { val: 1000 } ]
```

这就是浅拷贝的限制所在了。它只能拷贝一层对象。如果有对象的嵌套，那么浅拷贝将无能为力。但幸运的是，深拷贝就是为了解决这个问题而生的，它能解决无限级的对象嵌套问题，实现彻底的拷贝。

# 二、浅拷贝（Shallow Copy）

## 1. 什么是浅拷贝

创建一个新对象，这个对象有着原始对象属性的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如属性是引用类型，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。

![img](assets/2019-07-24-060221.png)

上图中，`SourceObject` 是原对象，其中包含基本类型属性 `field1` 和引用类型属性 `refObj`。浅拷贝之后基本类型数据 `field2` 和 `filed1` 是不同属性，互不影响。但引用类型 `refObj` 仍然是同一个，改变之后会对另一个对象产生影响。

## 2. 浅拷贝使用场景

- `Object.assign()`

`Object.assign()` 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

注意：`Object.assgin()` 拷贝的是对象的属性的引用，而不是对象本身。

```js
let a = {
    name: "muyiy",
    book: {
        title: "You Don't Know JS",
        price: "45"
    }
}
let b = Object.assign({}, a);
console.log(b);
// {
// 	name: "muyiy",
// 	book: {title: "You Don't Know JS", price: "45"}
// } 
```

- 扩展运算符 `...`

```js
let arr = [1, 2, 3];
let newArr = [...arr];
```

- `Array.prototype.slice()`

`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end`（不包括 `end`）决定的原数组的**浅拷贝**。原始数组不会被改变。

```js
let arr = [1, 2, 3];
let newArr = arr.slice();
newArr[0] = 100;

console.log(arr);//[1, 2, 3]
```

- `Array.prototype.concat()`

```js
let arr = [1, 2, 3];
let newArr = arr.concat();
newArr[1] = 100;
console.log(arr);//[ 1, 2, 3 ]
```

## 3. 手动实现浅拷贝

思路：遍历对象，然后把属性和属性值都放在一个新的对象

```js
var shallowCopy = function(obj){
    // 只拷贝对象
    if(typeof obj !== 'object' || obj === null) return;
    // 根据 obj 的类型判断是新建一个数组还是对象
    var newObj = obj instanceof Array ? [] : {};
    // 遍历 obj，并判断是 obj 的属性才拷贝
    for(var key in obj){
        if(obj.hasOwnProperty(key)){
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```



# 三、深拷贝（Deep Copy）

## 1. 什么是深拷贝

深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。

![img](assets/2019-07-24-060222-1592660818325.png)

## 2. 深拷贝使用场景

`JSON.parse(JSON.stringify(object))`

```js
let a = {
    name: "muyiy",
    book: {
        title: "You Don't Know JS",
        price: "45"
    }
}
let b = JSON.parse(JSON.stringify(a));
console.log(b);
// {
// 	name: "muyiy",
// 	book: {title: "You Don't Know JS", price: "45"}
// } 

a.name = "change";
a.book.price = "55";
console.log(a);
// {
// 	name: "change",
// 	book: {title: "You Don't Know JS", price: "55"}
// } 

console.log(b);
// {
// 	name: "muyiy",
// 	book: {title: "You Don't Know JS", price: "45"}
// } 
```

数组同理，但是该方法会有以下几个问题：

1. 会忽略 `undefined`，`Symbol`

2. 无法解决**循环引用**的问题，例子：

   ```js
   var a = { val:2 };
   a.target = a;
   ```

   拷贝 a 会出现栈溢出，因为出现了**无限递归**的情况。

3. 不能序列化**函数**！

4. 无法拷贝一些**特殊对象**，诸如 `RegExp,Date,Set,Map` 等。