# ES6

## let 和 const 命令

### JS 的变量声明

- 变量声明分为 创建 create、初始化 initialize、赋值assgin
- 变量提升

	- var 声明会在代码执行前就将 [ 创建变量 ]，并将其 [ 初始化 ] 为 undefined 。
	- function 声明会在代码执行前就 [创建、初始化并赋值]
	-  let 声明会在代码执行前就 [创建]，但是会等到执行到该行命令时才会进行 [初始化]
	- const 和 let 只有一个区别，只有 [创建] 和 [初始化]，没有 [ 赋值 ] 过程

### let 命令

- 描述

	- ES6 新增了 let 命令，用于声明变量。其用法类似于 var，但是所声明的变量只在 let 命令所在的代码块有效，在代码块外调用 let 声明的变量会报错。
	- 只要块级作用域内存在 let 命令，它所声明的变量就"绑定"（binding）这个区域，不再受外部影响。

- 特性

	- 不存在变量提升

		- var 命令会发生“变量提升”(也就是执行前会在作用域顶部创建并初始化变量为 undefined），
		- let 命令所声明的变量一定要在声明(创建并初始化)后使用。

	- 暂时性死区(TDZ, temporal dead zone)

		- 只要块级作用域内存在 let 命令，它所声明的变量就"绑定"（binding）这个区域，不再受外部影响。
		- ES6 明确规定，如果区块中存在 let 和 const 命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域。只要在声明之前就使用这些变量，就会报错。
		- 本质：只要进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

	- 不允许重复声明

		- let 不允许在相同作用域内重复声明同个变量。

### 块级作用域

- 描述

	- ES5 只有全局作用域和函数作用域，没有块级作用域。

		- 第一种场景，内层变量可能会覆盖外层变量。
		- 第二种场景，用来计数的循环变量泄露为全局变量

	- let 实际上为 JavaScript 新增了块级作用域。

		- ES6 允许块级作用域的任意嵌套。
		- 外层作用域无法读取内层作用域的变量，内层作用域可以定义外层作用域的同名变量。

- 作用

	- 块级作用域的出现，实际上使得广泛应用的立即执行函数（IIFE）不再必要了。
	- IIFE写法

		- (function () { var tmp = ...; } ());

	- 块级作用域写法

		- { let tmp = ...; }

- 函数声明

	- 描述

		- ES5 规定，函数只能在顶级作用域和函数作用域之中声明，不能在块级作用域中声明。因为会被提升到作用域头部。
		- ES6 引入了块级作用域，明确允许在块级作用域中声明函数。在块级作用域中，函数声明语句的行为类似于 let，在块级作用域之外不可引用。

	- ES6 规定浏览器的实现可以不遵守上面的规定么人有自己的行为方式。（右侧3条规则只对ES6的浏览器有效，其他的环境实现不用遵守，仍旧将块级作用域的函数声明当作 let 处理即可。）

		- 允许在块级作用域内声明函数。
		- 函数声明类似于 var，即会提升到全局作用域或函数作用域的头部。
		- 同时，函数声明还会提升到所在的块级作用域的头部。

	- 注

		- 因为环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要应该写成函数表达式的形式，而不是函数声明语句。

			- 函数声明语句

				- { let a = 'secret'; function f() { return a; } }

			- 函数表达式

				- { let a = 'secret'; let f = function () { return a; } }

		- ES6 的块级作用域允许声明函数的规则只在使用大括号的情况下成立，如果没有使用大括号，就会报错。

### const 命令

- 描述

	- const 声明一个只读的常量。一旦声明，常量的值就不能改变。这意味着，const 一旦声明常量，就必须立即初始化，不能留到以后赋值。

- 特性

	- 只在声明所在的块级作用域内有效。
	- 声明的常量不会提升，也存在暂时性死区。
	- 不可重复声明。

- 本质

	- const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
	- 对于简单类型的数据（数值、字符串、布尔值）而言，值就保存在变量指向的内存地址中，因此等同于常量。
	- 对于复合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的只是一个指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。因此，将一个对象声明为常量时必须非常小心。
	- 注：对象本身是可变的，依然可以为其添加新的属性。

- 补充：冻结对象 Object.freeze 方法

### ES6 声明变量

- var 命令
- function 命令
- let 命令
- const 命令
- import 命令
- class 命令

### 顶层对象的属性

- 描述

	- 顶层对象在浏览器环境中指的是 window 对象。
	- 在 Node 环境中指的是 global 对象。

- ES5

	- 在ES5 中，顶层对象的属性与全局变量是等价的。
	- 弊端

		- 首先，无法在编译时就提示变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）
		- 其次，可能在不经意间就创建了全局变量。
		- 最后，顶层对象的属性是到处都可以独写的，这非常不利于模块化编程。
		- 另一方面，window 对象有实体含义，指的是浏览器的窗口对象，这样也是不合适的。

- ES6

	- ES6 为了改变上面这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量依旧是顶层对象的属性。
	- 另一方面规定，let 命令、const 命令、class 命令声明的全局变量不属于顶层对象的属性。
	- 也就是说明，从 ES6 开始，全局变量将逐步与顶层对象的属性隔离。

- 问题

	- ES5 的顶层对象，在各种实现中是不统一的

		- 在浏览器中，顶层对象是 window，但 Node 和 Web Worker 没有 window。
		- 在浏览器和 Web Worker 中，self 也指向顶层对象，但是 Node 没有 self。 
		- 在 Node 中，顶层对象是 global，其他环境都不支持。

	- 解决方案：同一段代码未了能在各种环境中都能取到顶层对象，目前一般是使用 this 对象

		- 局限性

			- 在全局环境中，this 会返回顶层对象，但是 Node 模块和 ES6 模块中，this 返回的是当前模块。
			- 对于函数中的 this，如果函数不是作为对象的方法运行，而是单纯的作为函数运行，this 会指向顶层对象。但是，严格模式下，this 会返回 undefined。
			- 不管严格模式还是普通模式下，new Function('return this')() 总会返回全局对象。但是，如果浏览器使用了 CSP（Content Security Policy，内容安全政策），那么 evel、new Function 这些方法都可能无法使用。

	- 提案

		- 在语言的标准层面引入 global 作为顶层对象，在所有环境下，都可以拿到。
		- 垫片库 system.global 模拟了这个提案。

- 勉强能使用的两个方法

  // 方法一
  (typeof window !== 'undefined'
  			? window
  			: ( typeof process === 'object') && typeof require === 'function' && typeof global === 'object')
  				? global
  				: this
  );
  
  // 方法二
  var getGlobal = function () {
  	if (typeof self !== 'undefined') 
  	{ return self; }
  	if (typeof window !== 'undefined') 
  	{ return window ; }
  	if (typeof global !== 'undefined') 
  	{ return global; }
  	throw new Error('unable to locate global object');
  }

## 解构赋值

### 描述

- 解构赋值是对赋值运算符的扩展
- 是一种针对数组或对象进行模式匹配，然后对其中的变量进行赋值。

### 规则

- 只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值都会报错。

### 数组的解构赋值

- 描述

	- ES6 允许按照一定模式从数组和对象中提取值，然后对变量进行赋值，这被称为解构（Destructuring)

- 基本用法

	- 本质上，这种写法属于"模式匹配"，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

		- let [a,b,c] = [1, 2, 3];

			- a = 1、b=2、c=3

		- let [foo, [ [bar]], baz] = [1, [ [2], 3] ];

			- foo=1、bar=2、baz=3

	- 如果解构不成功，变量的值就等于 undefined。

		- let [x, y, ...z] = ['a'];

			- x='a'、y=undefined、z=[]

	- 另一种情况是不完全解构，即等号左边的模式只匹配一部分的等号右边的数组。

		- let [x, y] = [1, 2,3];

			- x=1、y=2

	- 如果等号的右边不是数组（或者严格来说不是可遍历(Iterator 接口)的结构），那么将会报错。

		- let [foo] = 1; let [foo]=false;

			- 报错

- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。
- 默认值

	- 描述

		- 解构赋值允许指定默认值，且当右边对应位置的值严格等于 undefined 时才生效。
		- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

	- 示例

		- let [foo = true] = [];

			- foo=true

		- let [x = 1] = [null];

			- x=null

		- null 不严格等于 undefined。

	- 注

		- ES6 内部严格使用相等运算符（===）判断一个位置是否有值。所以。如果一个数组成员不严格等于 undefined，默认值是不会生效的。

### 对象的解构赋值

- 描述

	- 解构不仅可以用于数组，还可以用于对象。
	- 与数组一样，解构也可以用于嵌套解构的对象。

- 示例

	- let { foo,bar } = { foo: "aaa", bar:"bbb" };

		- foo=“aaa”、bar="bbb"

- 与数组的不同

	- 数组的元素是按次序排列的，变量的取值是由它的位置决定的。
	- 而对象的属性没有次序，变量必须与属性同名才能取到正确的值。

- 实质

	- 对象的解构赋值是对象属性简洁表达式的简写

		- let { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };

	- 也就是说，对象的解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的是后者(变量)，而不是前者(匹配的模式)。

- 默认值

	- 描述

		- 默认值生效的条件是，对象的属性值严格等于 undefined。

- 注

	- 如果要将一个已经声明的变量用于解构赋值，必须非常小心。

		- let x; {x} = {x:1};

			- 报错

		- 因为JS 引擎会将 {x} 理解成一个代码块，从而发生错误。只有不将大括号写在行首，避免JS引擎将其解释成代码块，才能解决这个问题。
		- 正确：( {x} = {x:1} );

- 应用

	- 对象的解构赋值可以很方便的将现有对象的方法赋值到某个变量。

		- let { log,sin,cos } = Math;
		- 将 Math 对象的三个方法赋值到对应变量上。

### 字符串的解构赋值

- 描述

	- 字符串也可以解构赋值，因为此时的字符串被转换成了一个类似数组的对象。
	- 补：类似数组的对象都有一个 length 属性

- 示例

	- let [a,b,c,d,e] = 'hello'

		- a="h"、b="e"、c="l"、d="l"、e="o"

### 数值和布尔值的解构赋值

- 描述

	- 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

- 示例

	- let  {toString: s} = 123;

		- s === Number.prototype.toString // true

	- let  {toString: s} = true;

		- s === Boolean.prototype.toString // true

	- 上面的代码中，数值和布尔值的包装对象都有 同String 属性，因此变量 s 都能取到值。

### 函数参数的解构赋值

- 描述 

	- 函数的参数也可以使用解构赋值。
	- 函数参数的解构也可以使用默认值。

- 示例

	- function add([x, y]) { return x + y };  add([1, 2]); // 3

### 圆括号问题

- 描述

	- 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。
	- ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。（只要有可能，就不要在模式中放置圆括号）。

- 不能使用圆括号的情况

	- 变量声明语句

		- let [(a)] = [1];

			- 报错

	- 函数参数

		- function f([(z)]) { return z;}

			- 报错

	- 赋值语句的模式

		- ({ p:a }) = { p: 42 };

			- 报错

		- [({ p:a }), { x:c }] = [{}, {}];
		- 将整个模式或部分模式放在圆括号内，都会报错

- 可以使用的情况

	- 赋值语句的非模式部分可以使用圆括号

		- [(b)] = [3]

			- 正确

		- ( { p:(d) } = {} );

			- 正确

		- 因为它们都是赋值语句，不是声明语句，另外它们的括号都不属于模式的一部分。
		- 第一个，模式是取数组的第一个成员，跟圆括号无关。
		- 第二个 模式是 p 而不是 d。

### 用途

- 交换变量的值

	- let x = 1; let y = 2; [x,y] = [y,x];
	- 上面的代码交换变量 x 和 y 的值，这样的写法不仅简洁，而且易读，语义非常清晰。

- 从函数返回多个值

	- 描述

		- 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有解构赋值，取出这些值就非常方便。

	- 返回一个数组

		- function example() { return [1,2,3]; }    let [a,b,c] = example();

	- 返回一个对象

		- function example() { return { foo: 1, bar: 2 }; }    let { foo,bar }= example();

- 函数参数的定义

	- 描述

		- 解构赋值可以方便的将一组参数与变量名对应起来。

	- 参数是一组有次序的值（数组解构赋值）

		- function f([x,y,z]) {...}     f([1,2,3]);

	- 参数是一组无次序的值（对象解构赋值）

		- function f({x,y,z}) {...}     f({z: 3, y: 2, x: 1});

- 提取 JSON 数据

	- 描述

		- 解构赋值可以快速提取JSON 对象中的数据。

	- let jsonData = { id: 42, status: "OK",data: [1,2] };  let { id, status, data: number } = jsonData;

- 函数参数的默认值

	- 描述

		- 指定函数参数的默认值，就可以避免在函数体内部再写 var 参数 = 设定的默认值； 这样的语句

- 遍历 Map 结构

	- 描述

		- 任何部署了 Iterator 接口的对象都可以用  for...of 循环遍历。
		- Map 结构原生支持 Iterator 接口，配合变量的解构赋值获取键名和键值就非常方便。

	- 获取键名和键值

		- for( let [key, value] of map ) { ... }

	- 获取键名

		- for( let [key] of map ) { ... }

	- 获取键值

		- for( let [, value] of map ) { ... }

- 输入模块的指定方法

	- 描述

		- 加载模块时，往往需要指定输入的方法，解构赋值使得输入语句非常清晰。

	- const{ a, b } = require('xxx');

## 字符串的扩展

### 增强 Unicode

- 字符的 Unicode 表示法

	- 描述

		- JS 允许采用 \uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。

			- "\u0061"  = "a"

		- 但是这种表示法只限于码点在 \u0000 ~ \uFFFF 之间的字符。超出整个范围的字符，必须用 2 个双字节的形式表达。

			- "\uD832\uDFB7" = "吉"
			- '\u20BB7" = "7"
			- 若超过上线，如上会理解成 \u20BB+7

		- ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。（大括号表示法与四字节的 UTF-16编码是等价的。）

			- "\u{20BB7}" = "吉"

	- 补充：JS 表示字符的方法

		- ‘z‘ === ’z‘
		- '\z' === 'z'

			- 进行转义

		- '\172' === 'z'

			- 八进制

		- '\x7A' === 'z'

			- 十六进制

		- '\u007A' === 'z'

			- unicode 方式

		- '\u{7A}' === 'z'

			- ES6 增强的 unicode 方式

- codePoinAt()

	- 描述

		- JS内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。
		- 对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JS不能正确处理，字符串长度会被误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前 2 个字节和后2个字节的值。
		- ES6 提供了 codePoinAt 方法，能够正确处理 4 个 字节储存的字符，返回 32位的 UTF-16 字符的码点(十进制)。

	- 参数

		- 字符在字符串中的位置（从 0 开始）。

- String.fromCodePoint()

	- 描述

		- ES5 提供了 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符
		- ES6 提供了 String.fromCodePoint 方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。

	- 参数

		- 若该方法有多个参数，则它们会被合并成一个字符串返回。

	- 注：fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。

- 字符串的遍历器接口

	- 描述

		- ES6 为字符串添加了遍历器接口(Iterator)，使得字符串可以由 for...of 循环遍历。
		- 除了遍历字符串，这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点。

- at() 提案

	- 描述

		- ES5 对字符串对象提供了 charAt 方法，返回字符串给定位置的字符，该方法不能识别码点大于 0xFFFF 的字符。
		- 提案提出字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF  的字符，返回正确的字符。

	- 目前可以通过垫片库实现。

### 扩展 字符串对象

- 验证字符串

	- 描述

		- 传统上，JS 中只有 indexOf 方法可以用来确定一个字符串是否包含在另一个字符串中。

			- indexOf()

				- 返回某个指定的字符串值在字符串种首次出现的位置。
				- 参数

					- 必需，规定需检索的字符串值。
					- 可选，规定在字符串种开始检索的位置，默认为首字符。

		- ES6 又提供了 3 种新方法

			- includes()

				- 返回布尔值，表示是否找到了参数字符串。

			- startsWith()

				- 返回布尔值，表示参数字符串是否在源字符串的头部。

			- endsWith()

				- 返回布尔值，表示参数字符串是否在源字符串的尾部。

			- 参数 : 与 indexOf 相同。
			- 使用第二个参数时，endsWith 针对的是前 n 个字符(也就是匹配的字符串长度)，而其他两个方法针对从第 n 个位置到字符串结束位置之间的字符 。

- repeat()

	- 描述

		- 该方法 返回一个新字符串，表示将原字符串重复 n 次。

	- 参数

		- 要 重复的次数。若是正小数，会被向下取整(Math.floor)，0到-1则等同于0，负数或者Infinity 会报错，参数 NaN 等同于 0。参数是字符串，则会转换为数字。

- padStart()、padEnd()

	- 描述

		- ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。
		- padStart() 用于头部补全，padEnd() 用于尾部补全。

	- 参数

		- 用来指定字符串的最小长度。

			- 若原字符串的长度等于或大于指定的最小长度，则返回原字符串。
			- 如果用来补全的字符串与原字符串的长度之和超过了指定的最小长度，则会截取超出的位数的补全字符串。

		- 用来补全的字符串。

			- 若省略第二个参数，则会用空格来补全。

	- padStart 用途

		- 为数值补全指定位数

			- '1'.padStart(10, '0'); // "0000000001"

		- 提示字符串格式

			- '12'.padStart(10, 'YYYY-MM-DD');   //"YYYY-MM-12"

- 模板字符串

	- 描述

		- 传统的 JS 输出模板通常是用标签加字符串拼接(+) 的方法来写的。

			- '<b>xxx' + 变量 +'</b>' 

		- ES6 引入模板字符串。

			- `<b>xxx${变量}</b>`

		- 模板字符串(template string)是增强版的字符串，用反引号(`)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串种嵌入变量，也可以嵌套使用。

	- 嵌入变量

		- 用 ${ } 来包裹变量。 
		- {} 内可以放入任意的 JS 表达式，可以进行运算，以及引用对象属性，也可以调用函数。若是字符串，则会原样输出。
		- 若 {} 内的值不是字符串，按照一般的规则转为字符串。比如，大括号内是一个对象，将默认调用对象的 toString 方法。

	- 表示多行字符串

		- 所有的空格和缩进都会被保留在输出中。(若不想要换行，可以用 trim 方法消除 )

	- 标签模板

		- 功能

			- 模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为“标签模板”功能（tagged template）。
			- 标签模块其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。
			- 如果模板字符串中有变量，就不再是简单调用了，而是要将模板字符串先处理成多个参数，再调用函数。

		- 示例

			- alert`123`  等同于 alert(123)
			- var a = 5; alert`hello ${ a } world` 等同于 alert(['hello ', ' word'], 5);

		- 作用

			- 一个重要应用就是过滤 HTML 字符串，防止用户输入恶意内容 。
			- 可以使用标签模板在 JS 语言中嵌入其他语言。

		- 模板处理函数的第一个参数（模板字符串数组）还有一个 raw 属性，保存的 是转义后的原字符串。

			- console.log`123` // ["123", raw: Array[1]]

	- 限制

		- 模板字符串会默认将字符串 转义，导致无法 嵌入其他语言
		- 提 案

			- 放松对字符串转义的限制，如果遇到不合法 的字符串转义，就返回 undefined，而不是报错，并且 raw 属性上 可以得到原始字符串。

- String.raw()

	- 描述

		- ES6 还为原生的 String 对象提供了一个 raw 方法。
		- 该方法往往用来充当模板字符串的处理函数，返回一个反斜线都被转义（即反斜线前面再加一个反斜线）的字符串，对应于替换变量后的模板字符串。

	- 示例

		- String.raw`Hi\n${2+3}!`

			- // "Hi\\n5!"

	- 注：若原字符串中的反斜线已经转义，那么不会做任何处理。
	- 用途

		- 作为处理模板字符串的基本方法，它会将所有变量替换，并对反斜线进行转义，以便于下一步作为字符串使用
		- 也可以作为正常函数使用。

			- 第一个参数是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组（或类数组）。
			- 示例

				- String.raw({raw: 'test'}, 0 ,1, 2);

					- // 't0e1s2t'

## 正则的扩展

### RegExp 构造函数

- 描述

	- 在 ES5 中，RegExp 构造函数的参数有两种情况。

		- 第一种情况是，参数是字符串，这是第二个参数表示正则表达式的修饰符(flag)。

			- var regex = new RegExp('xyz', 'i');
			- 等价于：var regex = /xyz/i;

		- 第一种情况是，参数是一个正则表达式，这时会返回一个原有正则表达式的拷贝。但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。

			- var regex = new RegExp(/xyz/i);
			- 等价于：var regex = /xyz/i;

	- ES6 改变了第二种行为，如果 RegExp  构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有正则表达式的修饰符，只使用新指定的修饰符。

		- new RegExp(/abc/ig, 'i').flags; // "i"

### 字符串的正则方法

- 字符串对象共有 4 中方法可以调用正则表达式。

	- match()

		- 该方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。

	- replace()

		- 该方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

	- search()

		- 该方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。

	- split()

		- 该方法用于把一个字符串分割成字符串数组。

- ES6 使这4 个方法在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则表达式有关的方法都定义在 RegExp 对象上。

	- String.prototype.match 调用 RegExp.prototype[Symbol.match]
	- String.prototype.replace 调用 RegExp.prototype[Symbol.replace]
	- String.prototype.search 调用 RegExp.prototype[Symbol.search]
	- String.prototype.split 调用 RegExp.prototype[Symbol.split]

### u 修饰符

- 描述

	- ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于 \uFFFF 的 Unicode 字符。也就是说，可以正确处理 4 个字节的 UTF-16 编码。

		- /^\uD83D/u.test('\uD83D\uDC2A');   //false
		- /^\uD83D/.test('\uD83D\uDC2A');   //true
		- 上面代码中，\uD83D\uDC2A 是一个 4 字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持 4 字节的 UTF-16 编码，会将其识别为 2 个字符，导致第二行代码结构为 true。加了 u 修饰符以后，ES6 就会识别其为一个字符，所有第一行代码结果为 false。

- 作用：修改以下正则表达式的行为

	- 点字符

		- 点( . )字符在正则表达式中的含义是除换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。

	- Unicode 字符表示法

		- ES6 新增了用大括号表示 Unicode 字符的表示法，这种表示法在正则表达式中必须加上 u 修饰符才能识别当中的大括号，否则会被解读为量词(匹配前面字符特定次数)。

	- 量词

		- 使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。

	- 预定义模式

		- u 修饰符也影响到预定义模式能否正确识别码点大于 0xFFFF 的 Unicode 字符。

	- i 修饰符

		- 有些 Unicode 字符的编码不同，但是字形很相近，比如 \u004B 与 \u212A 都是大写的 K，若不加 u 修饰符就无法识别非规范的 K 字符。

### y 修饰符

- 描述

	- y 修饰符的作用与 g 修饰符类似。也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就行，而 y 修饰符会确保匹配必须从剩余的第一个位置开始，这也就是它名称 “粘连”(sticky) 的含义。

### stick 属性

- 描述

	- 与 y 修饰符相匹配，ES6 的正则对象多了 sticky 属性，表示是否设置了 y 修饰符。

### flags 属性

- 描述

	- ES6 为正则表达式新增了flags 属性，会返回正则表达式的修饰符。

### 具名组匹配

## 数值的扩展

### BigInt 数据类型

- 描述

	- 新增的第八个基本类型
	- BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。
	- 可以用在一个整数字面量后面加 n 的方式定义一个 BigInt，如：10n，或者调用函数 BigInt()。

- 构造器

	- BigInt()——创建 BigInt 对象。

- 类型信息

	- 使用 typeOf 测试时，BigInt 对象返回 “bigint”

- 运算

	- 以下操作符可以和 BigInt 一起使用： +、`*`、`-`、`**`、`%` 。除 >>> （无符号右移）之外的 位操作 也可以支持。因为 BigInt 都是有符号的， >>> （无符号右移）不能用于 BigInt。
	- 为了兼容 asm.js ，BigInt 不支持单目 (+) 运算符。

- 比较

	- BigInt 和 Number 不是严格相等的，但是宽松相等的。
	- 两者也可以混合在一个数组内并排序。
	- 注意被  Object 包装的 BigInts 使用 object 的比较规则进行比较，只用同一个对象在比较时才会相等。

- 条件

	- BigInt 在需要转换成 Boolean 的时表现跟 Number 类似：如通过 Boolean 函数转换；
	- BigInt 在需要转换成 Boolean 的时表现跟 Number 类似：如通过 Boolean 函数转换；用于 Logical Operators  ||, `&&`, 和 ! 的操作数；或者用于在像 if statement 这样的条件语句中。

### 二进制和八进制表示法

- 描述

	- ES6 提供了二进制和八进制数值的新写法，分别用前缀 0b（或 0B）和 0o（或 0O）表示。
	- 从 ES5 开始，在严格模式中，八进制数值就不再允许使用前缀 0 表示，ES6 进一步明确，要使用前缀 0o 表示。

- 注：可用 Number 方法将 0b 和 0x 前缀的字符串数值转换为十进制数值。

### Number.isFinite()、Number.isNaN()

- Number.isFinite() 用来检查一个数值是否为有限的（finite).
- Number.isNaN() 用来检查一个值是否为 NaN。只有对于 NaN 才返回 true，非 NaN一律返回 false。
- 这两个新方法与传统的全局方法 isFinite() 和 isNaN 的区别在于：

	- 传统方法先调用 Number() 将非数字转为数值，再进行判断。
	- 新方法只对数值有效，对于非数值一律返回 false。

### Number.parseInt()、Number.parseFloat()

- 描述

	- ES6 将全局方法 parseInt() 和 parseFloat() 移植到了 Number 对象上面，行为完全保持不变。

- 目的

	- 逐步减少全局性方法，使得语言逐步模块化。

### Number.isInteger()

- 描述

	- 该方法用来盘对一个值是否为整数。

- 注

	- 在 JavaScript 中，整数和浮点数是同样的储存方法，所以 3 和 3.0  被视为同一个值。

### Number.EPSILON

- 描述

	- ES6 在 Number 对象上面新增了一个极小的常量——Number.EPSILON(2.220446049250313e-16)
	- 实质是一个可以接受的误差范围。

- 目的

	- 为浮点数计算设置一个误差范围，因为浮点数的计算是不精确的。
	- 如果这个计算的误差能够小于 Number.EPSILON，就可以认为是正确的。

- 浮点数运算的误差检验函数

	- function withinErrorMargin(left, right)  {                                   
                  return Math.abs(left - right) < Number.EPSILON;    }

### 安全整数和 Number.isSafeInteger()

- 安全整数

	- 描述

		- JS 能够准确表示的整数范围在 -2^53 到 2^53 之间（不含两个端点），超过这个范围就无法精确表示。

			- Math.pow(2,53)  //9007199254740992

		- Math.pow(2, 53) === Math.pow(2, 53) + 1 // true
		- 上面的代码中，超出 2 的 53 次方之后，一个数就不精确了。
		- ES6 引入了 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 两个常量来表示这个范围的上下限。

- Number.isSafeInteger()

	- 描述

		- 用来判断一个整数是否落在安全整数范围内。

	- 实现

		- 跟安全整数的两个边界值比较一下即可

	- 注

		- 实际使用这个函数时，需要注意验证运算结果是否落在安全整数的范围内，另外不要只验证运算结果，还要同时验证参与运算的每个值。

### Math 对象的扩展

- 描述

	- ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用

- Math.trunc()

	- 描述

		- 该方法用于去除一个数的小数部分，返回整数的部分。
		- 对于非数值，Math.trunc 内部使用 Number 方法将其先转换为数值，对于空值和无法截取整数的值，返回 NaN。

	- 模拟实现

	  Math.trunc = Math.trunc || function(x) {
	  	return x < 0 ? Math.ceil(x) : Math.floor(x);
	  }

- Math.sign()

	- 描述

		- 该方法用来判断一个数到底是正数、负数，还是零。对于非数值，会先将其转换为数值。

	- 返回值

		- 参数为正数，返回 +1
		- 参数为负数，返回 -1
		- 参数为 0，返回 0
		- 参数为 -0，返回 -0
		- 其他值，返回 NaN

	- 模拟实现

	  Math.sign = Math.sign || function (x) {
	  	x = +x;	// 转换为数值
	  	if( x === 0 || isNaN(x) ) {
	  		return x;
	  	}
	  	return x > 0 ? 1 : -1;
	  }

- Math.cbrt()

	- 描述

		- 该方法用于计算一个数的立方根。

	- 模拟实现

	  Math.cbrt = Math.cbrt || function(x) {
	  	var y = Math.pow(Math.abs(x), 1/3);
	  	return x < 0 ? -y : y;
	  }

- Math.clz32()

	- 描述

		- JS 的正数使用 32 位二进制形式表示，Math.clz32 方法返回一个数的 32 位无符号正数形式有多个前导0。

- Math.imul()

	- 描述

		- 返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。

- Math.fround()

	- 描述

		- 该方法返回一个数的单精度浮点数形式。
		- 对于整数来说，该方法的返回结果不会有任何不同，区别在于那些无法用 64 个二进制位精确表示的小数。这时，该方法会返回最这个小数的单精度浮点数。

	- 模拟实现

	  Math.fround = Math.fround || function(x) {
	  	return new Float32Array([x])[0];
	  }

- Math.hypot()

	- 描述

		- 该方法返回所有参数的平方和的平方根。
		- 参数自动转换位数值，只要有一个参数无法转换为数值，就会返回 NaN。

- 对数方法

	- Math.expm1()

		- Math.expm1(x) 返回 e^x - 1，即 Math.exp(x) - 1

	- Math.log1p()

		- Math.log1p(x) 返回 ln(1+x)，即 Math.log(1+x)。如果 x 小于 -1，则返回 NaN。

	- Math.log10()

		- Math.log10(x) 返回以10为底的 x 对数。如果 x 小于 0，则返回 NaN。

	- Math.log2()

		- Math.log2(x) 返回以 2 为底的 x 的对数。如果 x 小于 0 ，则返回 NaN。

- 双曲函数

	- Math.sinh(x): 返回 x 的双曲正弦（hyperbolic sine）
	- Math.cosh(x): 返回 x 的双曲余弦（hyperbolic cosine）
	- Math.tanh(x): 返回 x 的双曲正切（hyperbolic tangent）
	- Math.asinh(x): 返回 x 的双曲正弦（inverse hyperbolic sine）
	- Math.acosh(x): 返回 x 的双曲余弦（inverse  hyperbolic cosine）
	- Math.atanh(x): 返回 x 的双曲正切（inverse  hyperbolic tangent）

- Math.signbit()

	- 描述

		- 该方法用来判断一个值的正负，但如果参数是 -0，会返回 -0。

- 指数运算符

	- 描述

		- ES2016 新增了一个指数运算符( ** )。

			- 2 ** 3  // 8

		- 指数运算符可以与等号结合，形成一个新的赋值运算符（ **= ）。

	- 注

		- 在 V8 引擎中，指数运算符与 Math.pow 的实现不相同，对于特别大的运算结果，两者会有细微的差异。

## 函数的扩展

### 函数参数的默认值

- 描述

	- 在 ES6 之前，不能直接为函数指定默认值，采用变态的方法，在函数内部设置参数值。

		- function log(x, y) { y = y|| 'world';console.log(x, y);}
		- 这种写法的缺点在于，如果参数 y 赋值了，但是对于的布尔值为 false，则该赋值不起作用。
		- 为了避免这个问题，通常需要先判断参数是否被赋值（严格等于 undefined），如果没有，再令其等于默认值。

	- ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。

		- function log(x, y = 'world') { ... }

- 优势

	- 阅读代码的人可以立即意识到哪些参数是可以省略的，不要看函数体或文档
	- 有利于将来的代码优化，即使未来的版本彻底拿掉这个参数，也不会导致以前的代码无法运行。

- 注

	- 参数变量是默认声明的，所以不能用 let 或 const 再次声明。
	- 使用参数默认值时，函数不能有同名参数。
	- 参数默认值不是传值的，而是每次都重新计算默认值表达式的值，参数默认值是惰性求值的。

- 与解构赋值默认值结合使用

	- 描述

		- 参数默认值可以与解构赋值的默认值结合起来使用

	- 示例

		- function foo({ x, y = 5 }) { ... }

			- 只使用了对象的解构赋值默认值。

		- function fetch( url, { body = ' ', method = 'GET' } ) { }

			- 只使用了对象的解构赋值默认值。

		- 上面的写法不能省略第二个参数，如果结合参数的默认值，就可以省略第二个参数，这时就出现了双重默认值。
		- function fetch( url, { method = 'GET' } = {} ) {}

			- 对象的解构赋值默认值和函数参数的默认值。

		- 上面的代码中，函数没有第二个参数时，函数的默认值就会生效，然后才是解构赋值的默认值生效，变量 method 取到默认值 GET。

	- 写法差别

		- function m1( { x=0, y=0 } ={} ) { return [x,y]; }

			- m1(); // [0, 0]

				- m1({x:3, y: 8}); // [3, 8]

					- m1({x: 3}); // [3,0]

						- m1({}); // [0,0]

		- function m2( { x, y } = { x:0, y:0 } ) { return [x,y]; }

			- m2(); // [0, 0]

				- m2({x:3, y: 8}); // [3, 8]

					- m2({x: 3}); // [3,undefined]

						- m2({}); // [undefined, undefined]

		- 写法一中函数参数的默认值是空的，但是设置了对象解构赋值的默认值；
		- 写法二中函数参数的默认值是一个有具体属性的函数，但是没有设置对象解构赋值的默认值。

- 参数默认值的位置

	- 描述

		- 通常情况下，定义了默认值的参数应该是函数的尾参数。可以容易看出到底省略哪些参数。
		- 如果非尾部的参数设置默认值。实际上这个参数是无法省略的，除非显示输入 undefined 触发该参数等于默认值，null 无效果。

- 函数的 length 属性

	- 描述

		- 指定了默认值以后，函数的 length 属性将返回没有指定默认值的参数个数。也就是说指定了默认值后，length 属性将失真。
		- 因为 length 属性的含义是该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。
		- 同理，rest 参数也不会计入 length 属性。
		- 如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数。

- 作用域

	- 描述

		- 一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一给单独的作用域(context)。等到初始化结束，这个作用域就会消失。
		- 这种语法行为在不设置参数默认值时不会出现。

	- 示例

		- var x = 1; function f(x, y =x){ console.log(y); }  
 f(2); // 2
		- 上面代码中，参数 y 的默认值等于变量 x。调用参数 f 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 x 指向第一个参数x，而不是全局变量。
		- 函数调用时，函数体内的局部变量 x 影响不到默认值变量 x。 
		- var x = 1; function foo(x = x) { ... } foo();

			- 报错

		- 上面代码中，参数 x = x 形成一个单独作用域，实际执行的是 let x = x。由于暂时性死区，执行这行代码会产生“定义”错误。

	- 指定参数默认值为函数也同理。

- 应用

	- 可以用来指定某一个参数不得省略，如果省略就执行一个可以抛出函数的错误。
	- 可以将参数默认值设置为 undefined，表面这个参数是可以省略的。

### rest 参数

- 描述

	- ES6 引入了 rest 参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入其中。
	- 由于 rest 参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。

- 示例

	- function add(...values) { ... }
	- 使用 rest 参数代替 arguments 变量的例子

		- function sortNumbers() {   
    return Array.prototype.slice.call(arguments).sort();  }
		- const sortNumbers = (...numbers) => numbers.sort();

- 注

	- rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。
	- 函数的 lenght 属性不包括 rest 参数。

### 严格模式

- 描述

	- 从 ES5 开始，函数内部可以设定为严格模式。
	- ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值或扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
	- 这样规定的原因是，函数内部的严格模式同时适用于函数体和函数参数。但是，函数执行时，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方：只有从函数体之中才能知道参数是否以严格模式执行，但是参数却先于函数体执行。
	- 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑增加了复杂性。因此标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、扩展运算符，就不能显示指定严格模式。

- 规避限制

	- 第一种是设置全局性的严格模式，这是合法的。
	- 第二种是把函数包在一个无参数的立即执行函数里面。

### name 属性

- 描述

	- 函数的 name 属性返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到 ES6 才写入了标准。

- 注

	- ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的 name 属性会返回空字符串，而 ES6 的 name 属性会返回实际的函数名。
	- 如果将一个具名函数赋值给一个变量，ES5 ES6 都返回这个具名函数的原本的名字。
	- Function 构造函数返回的函数实例，name 属性的值为 anonymous(匿名)。
	- bind 返回的函数，name 属性值会加上 bound（界限、约束） 的前缀。

### 箭头函数

- 描述

	- ES6 允许使用“箭头”( => )定义函数。

- 基本用法

	- var f = v => v

		- 等价于 var f = function(v){ return v; };

	- 如果箭头函数不需要参数或需要多个参数，就使用圆括号代表参数部分。

		- var f = () => 5;

			- 等价于 var f = function() { return 5 };

		- var sum = (num1, num2) => num1 + num2;

			- 等价于 var sum = function(num1, num2) {        
 return num1 + num2 };

	- 如果箭头函数的代码块部分多于一条语句，就要使用大括号将其括起来，并使用 return 语句返回，

		- var sum = (num1, num2) => { return num1+num2; }

	- 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。

		- var getTempItem = id => ( { id:id, name : "Temp"} );

	- 箭头函数可以与变量解构结合使用。

		- const full = ( { first, last } ) => first+ ' ' + last;

			- 等价于 function full( person ){                                
   return person.first + ' '  + person.last;}

	- rest 参数结合箭头函数

		- const number = ( ...nums ) => nums;

- 作用

	- 箭头函数使得表达更加简洁

		- const isEven = n => n%2 == 0 ;
		- const square = n => n * n;

	- 简化回调函数

		- [1,2,3].map(function (x){ return x*x });

			- 简化：[1,2,3].map(x => x * x);

	- 嵌套的箭头函数

		- 部署管道机制(pipeline)，即前一个函数的输出是后一个函数的输入。

			- const pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);

- 注意事项

	- 函数体内的 this 对象就是定义时所在的对象，而不是使用时所在的对象。

		- 箭头函数可以让 setTimeout 里面的 this 绑定定义时所在的作用域，而不是指向运行时的作用域。
		- 箭头函数可以让 this 指向固定化，这种特性非常有利于封装 回调函数。
		- this 指向的固定化并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。
		- 由于箭头函数没有自己的 this，当然也就不能用 call()、apply()、bind() 这些方法去改变 this 指向。

	- 不可以当作构造函数。也就是说，不可以使用 new 命令，否则会抛出一个错误。

		- 因为箭头函数没有自己的 this ，所以不能用作构造函数。

	- 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
	- 不可以使用 yield 命令，因此箭头函数不能用作 Genertator 函数。

- 提案

	- ES7 提出了"函数绑定"(function bind) 运算符 " :: "

		- 用来取代 call、apply、bind 调用——并排的双冒号 ( :: )，双冒号左边是一个对象，右边是一个函数。 
		- 该运算符会自动将左边的对象作为上下文环境（即 this 对象）绑定到右边的函数上。
		- foo::bar;

			- 等价于  bar.bind(foo);

		- 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上。
		- 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。

### 尾调用

- 描述

	- 尾调用(Tail Call) 是函数式编程的一个重要概念
	- 意思是指某个函数的最后一步是调用另一个函数。
	- 尾调用不一定出现在函数尾部，只要是最后一步操作即可。

- 示例

	- function f(x) { return g(x); }

		- 函数f 的最后一步是调用函数g，这就叫尾调用。

	- 这些情况都不属于尾调用

		- function f(x) { let y = g(x); return y; }

			- 调用函数 g 之后还有赋值操作

		- function f(x) { return g(x) + 1; }

			- 调用后还有操作

		- function f(x) { g(x); }

			- 等同于 function g(x); return undefined;

- 尾调用优化

	- 描述

		- 尾调用之所以与其他调用不同，就在于其特殊的调用位置。
		- 补充

			- 函数调用会在内存形成一个“调用记录”，又称“调用帧”(call frame)，保存调用位置和内部变量等信息。
			- 如果在函数 A 的内部调用函数 B，那么在 A 的调用帧上方还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A，B 的调用帧才会消失。如果函数 B 内部还有调用函数 C，那就还有一个 C 的调用帧，以此类推。
			- 所有的调用帧就形成一个“调用栈”（call stack）。

		- 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，直接用内存函数的调用帧取代外层函数的即可。

	- 示例

		- function f(){ let m=1; let n=2; return g(m+n); }

			- 等同于 function f(){ return g(3); }

				- 等同于 g(3);

		- 上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g (3) 的调用帧。

	- 上面这种情况就叫作“尾调用优化”(Tail Call Optimization)，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时调用帧只有一项，这将大大节省内存。这就是尾调用优化的意义。
	- 注

		- 只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
		- function addOne(a) {                                                         
      var one = 1;                    
      function inner(b) { return b+one; }                   
      return inner(a); }
		- 上面的函数不会进行尾调用优化，因为内层函数 inner 用到了外层函数 addOne 的内部变量 one。

- 尾递归

	- 描述

		- 函数调用自身称为递归。如果尾调用自身就称为尾递归。
		- 递归非常耗费内存，因为需要同时保存成百上千个调用帧，很容易发生“栈溢出”错误(stack overflow)。但是对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

	- 阶乘函数示例

		- function factorial(n){                       
         if(n===1) return 1;                     
         return n * factorial(n - 1); }

			- factorial(5) // 120

		- 上面的代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度为 O(n)。如果改写成尾递归，只保留一个调用记录，则复杂度为 O(1)。
		- function tailFactorial(n, total){                       
         if(n===1) return total;                     
         return factorial(n-1, n * total); }

			- factorial(5,1) //120
			- f(5,1)=>f(4,5*1)=>f(3,4*5*1)=>f(2,3*4*5*1)=>f(1,2*3*4*5*1)

	- 斐波那契数列示例

		- 非尾递归版

			- function Fibonacci(n){                       
      if(n <= 1) {return 1};                     
     return Fibonacci(n-1)+Fibonacci(n-2)}

				- Fibonacci(10) //89
				- Fibonacci(100) // 堆栈溢出
				- Fibonacci(500) // 堆栈溢出

		- 尾递归优化

			- function Fibonacci(n, ac1=1, ac2=1){         
      if(n <= 1) {return ac2};                     
     return Fibonacci(n-1, ac2, ac1+ac2)};

				- Fibonacci(3,1,1) => F(2,1,2)=>F(1,2,3)=>3
				- Fibonacci(100) // 57314........
				- Fibonacci(10000) // Infinity

	- 递归函数的改写

		- 尾递归的实现往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。
		- 比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total，那就把这个中间变量改写成函数的参数。这样的缺点是不太直观，第一眼很难看出来，为什么计算 5 的阶乘需要传入两个参数 5 和 1，有两个解决方法。

			- 方法一是在尾递归函数之外再提供一个正常形式的函数。

				- function factorial(n) { return tailFactorial(n, 1); }
				- 函数式编程有一个概念，叫作柯里化(currying)，意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
				- function currying(fn, n){                       
      return function (m) {                    
             return  fn.call(this, m ,n);                     
      };                                                                               }
				- const factorial = currying(tailFactorial, 1);

					- factorial(5) // 120

				- 上面的代码通过柯里化将尾递归函数 tailFactorial  变为只接受 1 个参数的 factorial。

			- 方法二是采用 ES6 的函数默认值

				- function factorial(n, total = 1){                       
         if(n===1) return total;                     
         return factorial(n-1, n * total); }

					- factorial(5) // 120

				- 上面的代码中，参数 total 有默认值1，所有调用时不用提供这个值。

- 意义

	- “尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 也是如此，第一次明确规定，所以 ECMAScript 的实现偶读必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。

- 总结

	- 递归本质上是一种循环操作。纯粹的函数式编程没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua、ES6），只需要直到循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

- 注

	- ES6 的尾调用优化只在严格模式下开启，正常模式下是无效的。

		- 这时因为，在正常模式下函数内部有两个变量，可以跟踪函数的调用栈。

			- func.arguments：返回调用时函数的参数。
			- func.caller：返回调用当前函数的那个函数。

		- 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量(使用会报错)，所以尾调用模式仅在严格模式下生效。

- 尾递归优化的实现

	- 描述

		- 尾递归优化只在严格模式下生效，那么需要自己实现尾递归优化，才能在正常模式下或者在那些不支持该功能的环境中使用尾递归优化。

	- 原理

		- 尾递归之所以需要优化，原因是调用栈太多造成溢出，那么只要减少调用栈就不会溢出。—— 采用 “循环” 替代 “递归”。

	- 示例

		- function sum(x, y) {                                                     
   if(y >0) {  return sum(x+1, y-1);  }                
   else { return x; }                                                               }

			- 递归函数 参数 x 是需要累加的值， 参数 y 控制递归次数
			- sum(1, 100000) 一旦指定 sum 递归 100000 次，就会报错，提示超出调用栈的最大次数。

	- 使用蹦床(trampoline)可以将递归执行转为循环执行

		- function trampoline(f) {                                            
         while(f && f instanceof Function)        
          { f = f(); }                                                                         
          return f; }
		- 上面就是一个蹦床函数的一个实现，它接受一个函数 f 作为参数。只要 f 执行后返回一个函数，就继续执行。
		- 注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。
		- 然后要作的就是将原来的递归函数改写为每一步返回另一个函数(尾调用优化)。使用蹦床函数执行sum 就不会发送调用栈溢出。

			- function sum(x, y) {                                                     
   if(y >0) {  return sum.bind(null, x+1, y-1 )  }                
   else { return x; }                                                               }
			- 上面的代码中，sum 函数的每次执行都会返回自身的另一个版本。
			- trampoline(sum(1, 100000)); // 100001

		- 蹦床函数的核心是一个循环，只要传入参数是一个函数，就会调用这个函数，直到传参不再是一个函数位置。
		- 结合起来可以发现，蹦床函数的作用就是不断用一个新的函数代替原函数，直到递归边界，返回结果。
		- 需要注意的是，蹦床函数并不是真正的尾递归优化，因为蹦床函数每次 循环会产生一个新的调用帧。

	- 真正的尾递归优化

		- 要理解 tailCallOptimize() 这个函数，其关键点就在于其中的状态变量 "active" 和 保存当前递归的参数的变量“accumulated”。

			- 首次运行时，保存参数，"active" 变为 “true”，意思是已经进入尾递归优化阶段，之后的每次调用，都不会进入到 if 语句中，仅仅保存该次调用的参数。
			- 随后进入再次循环，accumulated 中保存了上次调用保存的参数，然后把刚刚保存的调用参数再次推出，让 f 函数执行，一直循环下去。
			- 直到最后达到递归边界，返回一个值，此时"accumulated" 为空，跳出循环，恢复状态，返回结果。整个过程的核心部分只有一个函数调用帧，因此这才是真正的尾递归调用优化。

		- 任何递归都可以写成循环 + 栈，实现任何尾递归转换成循环+栈执行而不需要针对每个尾递归函数写一个实现版本的思路。困难在于，任何尾递归，通用实现。而不是针对某一个递归函数。 

			- 栈中保存的数据，正是递归函数的参数。
			- 通用实现，那就必须依赖原来的递归函数，循环的终止条件，正是递归的终止条件。
			- 要将递归函数的参数入栈，而不修改原来的递归函数，就必须用一个函数代替递归函数被调用，从而取得函数入参。
			- 递归函数的终止条件，每个递归函数都不一样，但是如果递归函数没有被再次调用，说明已达到终止条件。即终止条件和递归函数的调用有关联。而递归函数每次调用，都会将参数入栈。所以可以根据栈中是否有元素，推断是否达到终止条件。

## 数组的扩展

### 扩展运算符

- 描述

	- 扩展运算符（spread）是三个点（ ... ），它如同 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
	- 扩展运算符后面还可以防止表达式，如果扩展运算符后面是一个空数组，则不产生任何效果。
	- 扩展运算符与正常的函数可以结合使用，非常灵活。
	- 扩展运算符背后调用的是遍历器接口(Symbol.iterator),如果一个对象没有部署该接口，就无法转换为数组。

- 示例

	- console.log(...[1, 2, 3]);  // 1 2 3 
	- console.log(1, ...[2,3,4], 5); // 1 2 3 4 5

- 用途

	- 该运算符主要用于函数调用

		- function push(array, ...items) { array.push(...items); }
		- function add(x,y){ return x+y; } add(...[4,38]); // 42
		- 上面的代码中，array.push(...items) 和 add(...[4,38]) 这两行都是函数的调用，它们都使用了扩展运算符。
		- 该运算符可以将一个数组变为参数序列。

	- 替代数组的 apply 方法

		- 描述

			- 由于扩展运算符可以展开数组，所以不再需要使用 apply 方法将数组转为函数的参数。

		- ES5 写法

			- function f(x,y,z){ //... } var args = [0,1,2]; f.apply(null, args);

		- ES6 写法

			- function f(x,y,z){ //...} var args = [0,1,2]; f(...args);

		- 示例

			- 应用 Math.max 方法简化求出一个数组中的最大元素

				- ES5: Math.max.apply(null, [14, 3, 77]);
				- ES6: Math.max(...[14, 3, 77]);
				- 等同于：Math.max(14, 3, 77);
				- 上面的代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用 Math.max 函数将数组转为一个参数序列，然后求最大值。有了扩展运算符以后就可以直接使用 Math.max 了。

			- 通过 push 函数将一个数组添加到另一个数组的尾部。

				- ES5

					- var arr1=[0, 1, 2]; var arr2=[3，4，5]; Array.prototype.push.apply(arr1, arr2);

				- ES6

					- var arr1=[0, 1, 2]; var arr2=[3，4，5]; arr1.push(...arr2);

				- 上面代码的ES5 写法中，push 方法的参数不可以是数组，所以只好通过 apply 方法变通使用 push 方法，有了 扩展运算符，就可以直接将数组传入 push 方法。

			- Date

				- ES5：new (Date.bind.apply(Date, [null, 2015, 1, 1]));
				- ES6：new Date(...[2015, 1, 1]);
				- 由于 Date 是内部对象，Date 上的方法只能由 Date 的实例调用，在使用上有限制。
				- 能实现构造函数的只有 bind 然后参数中带数组的只有 apply

- 应用

	- 合并数组

		- 描述

			- 扩展运算符提供了数组合并的新写法。

		- 示例

			- ES5: [1, 2].concat(more)
			- ES6: [1, 2, ...more]
			- var arr1 = ['a', 'b']; var arr2 = ['c']; var arr3 = ['d','e'];
			- ES5: arr1.concat(arr2, arr3);

				- [‘a’, 'b', 'c', 'd', 'e']

			- ES6: [...arr1, ...arr2, ...arr3];

				- [‘a’, 'b', 'c', 'd', 'e']

	- 与解构赋值结合

		- 描述

			- 扩展运算符可以与解构赋值结合起来，用于生成数组。

		- 示例

			- ES5: a = list[0], rest = list.slice(1);
			- ES6: [a, ...rest] = list

		- 注

			- 如果将扩展运算符用于数组赋值，则只能将其放在参数的最后一位，否则会报错。

	- 函数的返回值

		- 描述

			- JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。

		- 示例

			- var dateFields = readDateFields(database);
			- var d = new  Date(...dateFields);
			- 上面的代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date。

	- 字符串

		- 描述

			- 扩展运算符还可以将字符串转为真正的数组。

		- 示例

			- [...'hello'] // ["h", "e", "l", "l", "o"]
			- 上面的写法有一个重要的好处: 能够正确识别 32 位的 Unicode 字符。

		- 注

			- 普通字符串写法 ‘ ’.length 获取长度，JavaScript 会将 32 位的 Unicode 字符识别为 2 个字符，采用扩展运算符就没有这个问题。

		- 正确的返回字符串长度的函数

			- function length(str) { return [...str].length; }
			- 凡是涉及操作 32  位 Unicode 字符的函数都有这个问题。因此，最好都用扩展运算符改写。

	- 实现了 Iterator 接口的对象

		- 描述

			- 任何 Iterator 接口的对象都可以用扩展运算符转为真正的数组。
			- 对于没有部署 Iterator 接口的类似数组的对象，可以使用 Array.from 方法将 类数组转为真正的数组。

	- Map 和 Set 结构、Generator 函数

		- 描述

			- 扩展运算符内部调用的数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，如 Map 结构。
			- Generator 函数运行后会返回一个遍历器对象，因此也可以使用扩展运算符。

### Array.from()

- 描述

	- 该方法用于将两类对象转为真正的数组（浅拷贝的数组实例）：类似数组的对象（array-like object）和可遍历（iterable） 对象（包括ES6 新增的数据结构 Set 和 Map）。
	- Array.from 还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
	- 还可以传入 Array.from 第三个参数，用来绑定回调函数时的 this 对象。
	- Array.from() 可以将各种值转为真正的数组，并且提供 map 功能。这实际上意味着，只要有一个元素的数据结构，就可以先对它的值进行处理，然后转成规范的数组结构，进而可以用数量总舵的数组方法。

- 示例

	- 类似数组的对象转换为真正的数组

		- let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3 };

	- ES5的写法

		- var arr1 = [].slice.call(arrayLike);

			- // ['a', 'b', 'c']

	- ES6 的写法

		- let arr2 = Array.from(arrayLike);

			- // ['a', 'b', 'c']

	- 处理数组中的元素

		- Array.from(arrayLike, x => x * x);
		- 等同于：Array.from(arrayLike).map(x => x * x);
		- Array.from([1, 2, 3], (x) => x * x); // [1, 4, 9]

- 实际应用

	- 常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。Array.from 都可以将它们转换为真正的数组。
	- 只要是部署了 Iterator 接口的数据结构，Array.from 都能将其转为数组。扩展运算符(...) 也可以将某些数据结构转为数组。

		- 若对象无遍历器接口，则无法使用扩展运算符转换为数组。

	- Array.from 方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有 length 属性。因此，任何有 length 属性的对象，都可以通过该方法转换为数组，而这种情况扩展运算符无法转换。
	- 跟扩展运算符类似，将字符串转为数组，然后返回字符串的长度。（可以正确处理各种 Unicode 字符）

- 注

	- 对于还没有部署该方法的浏览器，可以用 Array.prototype.slice 方法替代。

		- const toArray = (() =>                                       
   Array.from ? Array.from : obj => [].slice.call(obj)                    
 )();

### Array.of()

- 描述

	- 该方法用于将一组值转换为数组
	- 这个方法的主要目的是弥补数组构造函数 Array() 的不足，因为参数个数的不同会导致 Array() 的行为有差异。
	- Array.of 基本上可以用来替代 Array() 或 new  Array()，并且不存在由于参数不同而导致的重载，它的行为非常统一。
	- Array.of 总是返回参数值组成的数组。如果没有参数，就返回一个空数组。

- 示例

	- Array()

		- Array() // []
		- Array(3) // [, , , ]
		- Array(3, 11, 8) // [3, 11, 8]

	- Array.of()

		- Array.of(3, 11, 8) // [3, 11, 8]
		- Array.of(3) // [3]
		- Array.of(3).length // 1

### 数组示例的 copyWithin()

- 描述

	- 数组示例的 copyWithin 方法会在当前数组内部将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法会修改当前数组。
	- Array.prototype.copyWithin(target, start=0, end=this.length)

- 参数

	- target (必选)：从该位置开始替换数据。
	- start (可选)：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
	- end (可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

- 示例

	- [1, 2, 3, 4, 5].copyWithin(0, 3)

		- // [4, 5, 3, 4, 5]

	- 上面的代码表示，将从 3 号位置直到数组结束的成员（4 和 5） 复制到从 0 号位置开始的位置，结果覆盖了原来的 1 和 2.
	- 将 3 号位复制到 0 号位

		- [1, 2, 3, 4, 5].copyWithin(0, 3, 4)

			- // [4, 2, 3, 4, 5]

	- -2 相当于 3 号位，-1 相当于4 号位

		- [1, 2, 3, 4, 5].copyWithin(0, -2, -1)

			- // [4, 2, 3, 4, 5]

### 数组实例的 find() 和 findIndex()

- find()

	- 描述

		- 数组实例的 find 方法用于找出第一个符合条件的数组成员。
		- 它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。
		- find 方法的回调函数可以接受 3 个参数，依次为当前的值、当前的位置和原数组。

	- 示例

		- [1, 5, 10, 15].find(function (value, index, arr) { 
  return value > 9 })   // 10

- findIndex()

	- 描述

		- 数组实例的 findIndex 方法的用法于 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 -1.

- 注

	- 这两个方法都可以接受第二个参数，用来绑定回调函数的 this 对象。
	- 另外，这两个方法都可以发现 NaN，弥补了数组的 IndexOf 方法的不足。

		- [NaN].indexOf(NaN);  // -1
		- [NaN].findIndex(y => Object.is(NaN, y)); // 0
		- 上面代码中，indexOf 方法无法识别数组的 NaN 成员，但是 findIndex 方法可以借助 Object.is 方法做到。（Object.is 方法判断两个值是否是相同的值）

### 数组实例的  fill()

- 描述

	- fill 方法使用给定值填充一个数组
	- fill 方法可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置

- 示例

	- ['a', 'b', 'c'].fill(7); // [7, 7, 7]
	- new Array(3).fill(7)
	- 上面的代码表明，fill 方法用于空数组的初始化时非常方便。数组中已有的元素会被全部抹去。
	- ['a', 'b', 'c'].fill(7, 1, 2); // ['a', 7, 'c']

### 数组实例 entries()、keys() 和 values()

- 描述

	- ES6 提供了 3 个新方法——entries()、keys() 和 values()——用于遍历数组。
	- 它们都返回一个遍历器对象，可用 for...of 循环遍历，唯一的区别在于，keys() 是对键名的遍历，values() 是对键值的遍历，entries() 是对键值对的遍历。
	- 如果不使用 for...of 循环，可以手动调用遍历器对象的 next 方法进行遍历。

- 示例

	- for(let index of ['a', 'b'].keys()) { 
   console.log(index); } // 0 // 1
	- for(let elem of ['a', 'b'].values())  { 
    console.log(elem);  } // 'a' // 'b'
	- for(let [index, elem] of ['a', 'b'].entries() ) { 
    console.log(index, elem); } // 0 "a" // 1 "b"

### 数组实例的 includes()

- 描述

	- Array.prototype.includes 方法返回了一个布尔值，表示某个数组是否包含给定的值。与字符串的 includes 方法类似，ES2016 引入了该方法。
	- 该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则会表示倒数的位置，如果为负数且它大于数组参数，则会重置为从 0 开始。如果是正数且大于数组长度，则该数组不会被搜索，返回 false。

- IndexOf

	- 在没有 includes 方法之前，通常使用数组的 indexOf 方法检查是否包含某个值。
	- if(arr.indexOf(el) !== -1) { //... }
	- 缺点

		- 不够语义化，其含义是找到参数值的第一个出现位置，所以要比较是否不等于 -1，表达起来不够直观。
		- 其内部使用严格相等运算符(===) 进行判断，会导致对 NaN 的误判。([NaN].indexOf(NaN) // -1)

- 注

	- [NaN].includes(NaN); // true

- 检查是否支持该方法，否则部署替代版本

	- const contains = ( () =>                                             
Array.prototype.includes ? (arr,value) => array.includes(value) )   :  (arr, value) => arr.some( el => el === value ) ) ();

- 注

	- Map 和 Set 数据结构有一个 has 方法，需要注意与 includes 区分。

		- Map 结构的 has 方法是用来查找键名的，比如 Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)
		- Set 结构的 has 方法是用来查找值的，比如 Set.prototype.has(value)、WeakSet.prototype.has(value)。

### 数组的空位

- 描述

	- 数组的空位指数组的某一个位置没有任何值。比如，Array 构造函数返回的数组都是空位。

- 注

	- 空位不是 undefined，一个位置的值等于 undefined 依然是有值的。空位是没用任何值，in 运算符可以说明这一点。

		- 0 in [undefined, undefined] // true
		- 0 in [, , ,] //false
		- 上面的代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。

- ES5

	- 描述

		- ES5 对空位的处理很不一致，大多数情况下会忽略空位。
		- forEach()、filter()、every() 和 some() 都会跳过空位。
		- map() 会跳过空位，但会保留这个值。
		- join() 和 toString() 会将空位视为 undefined，而 undefined 和 null 都会被处理成空字符串。

- ES6 

	- 描述

		- ES6 则是明确将空位转为 undefined。
		- Array.from 方法会将数组的空位转为 undefined。也就是说，这个方法不会忽略空位。 
		- 扩展运算符 (...) 也会将空位转为 undefined。
		- copyWithin() 会连空位一起复制。
		- fill() 会将空位视为正常的数组位置。
		- for...of 循环也会遍历空位。

- 注

	- 由于空位的处理规则非常不统一，所以建议避免出现空位。

## 对象的扩展

### 属性的简洁表示法

- 描述

	- ES6 允许直接写入变量和函数作为对象的属性和方法，这样的书写更加简洁。
	- ES6 允许在对象中只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。

- 示例

	- var foo = 'bar'; var baz = { foo }; baz // { foo: "bar" }
	- 等同于 var baz = { foo: foo };
	- 方法简写

		- var o = { method() { //... } };

- 注

	- 如果某个方法的值是一个 Generator 函数，则其前面需要加上星号。

### 属性名表达式

- 描述

	- JavaScript 语言定义对象的属性有两种方法。

		- obj.foo = true;
		- obj['a' + 'bc'] = 123;
		- 上面的方法一是直接用标识符作为属性名；方法二是用表达式作为属性名，这时要将表达式放在方括号内。

	- 但是，如果使用字面量方式定义对象（使用大括号），则在 ES5 中只能使用方法一（标识符）定义属性。

		- var obj = { foo: true, abc:123 };

	- ES6 允许字面量定义对象时用方法二（表达式作为对象的属性名），即把表达式放在方括号内。

		- let propKey = 'foo';                                                               let obj = { [proKey]: true, ['a' + 'bc'] : 123 };

- 注

	- 属性名表达式与简洁表示法不能同时使用，否则会报错。
	- 属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。

### 方法的 name 属性

- 描述

	- 函数的 name 属性返回函数名，对象方法也是函数，因此也有 name 属性。
	- 如果对象的方法中使用了取值函数(getter) 和存值函数(setter)，则 name 属性不是在该方法上面，而是在该方法属性的描述对象 get 和 set 属性上面，返回值是方法名前加上 get 和 set。

- 特殊情况

	- bind 方法创造的函数，name 属性返回 "bound" 加上原函数的名字。
	- Function 构造函数创造的函数，name 属性返回 "anonymous"。
	- 如果对象的方法是一个 Symbol 值，那么 name 属性返回的就是这个 Symbol 值的描述。

### Object.is()

- 描述

	- ES5 比较两个值是否相等，只有两个运算符：相等运算符( == ) 和严格相等运算符( === )。
	- 它们都有缺点，前者会自动转换数据类型，厚泽的 NaN 不等于自身，以及 +0 等于 -0。
	- JavaScript 缺乏这样一种运算符：在所有环境中，只要有两个值是一样的，它们就应该相等。
	- ES6 提出了“Same-value equality”(同值相等) 算法来解决这个问题。Object.is 就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格相等运算符( === ) 的行为基本一致。
	- 不同之处只有两个：一个是 +0 不等于 -0，二是 NaN 等于自身。

- 示例

	- Object.is('foo', 'foo'); // true
	- Object.is({}, {}); // false

- ES5 部署 Object.is

  Object.defineProperty(Object, 'is', { 
  	value: function(x, y){
  		if(x === y) {
  			// 针对+0 不等于 -0 的情况
  			return x !== 0 || 1/x === 1/y;
  		}
  		// 针对 NaN 的情况
  		return x !== x && y !== y;
  	},
  	configurable: true, // 可配置的
  	enumerable: false. // 不可枚举
  	writeable: true		  // 可写
   });

### Object.assign()

- 描述

	- Object.assign 方法用于将源对象(source)的所有可枚举属性复制到目标 对象(target)。
	- 该方法的第一个参数是目标对象，后面的参数都是源对象。
	- Object.assign 复制的属性是有限制的，只复制源对象的自身属性（不复制继承属性），也不复制不可枚举属性（enumerable:false）。属性名为 Symbol 值的数也会被 Object.assign 复制。

- 基本用法

	- 如果只有一个参数，Object.assign 会直接返回该参数。
	- 如果该参数不是对象，则会先转成对象，然后返回。由于 undefined 和 null 无法转为对象，所以如果将它们作为参数，就会报错。
	- 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则将有所不同。首先，这些参数都会转为对象，如果无法转成对象便会跳过。这意味着，如果 undefined 和 null 不在首参数便不会报错。
	- 其他类型的值（即数值、字符串和布尔值）不在首参数也不会报错。但是，除了字符串会以数值形式复制到目标对象，其他值都不会产生效果。

		- 其他的原始值都在包装对象的内部属性 [[PrimitiveValue]] 上面，这个属性是不会被 Object.assign 复制的。只有字符串的包装对象会产生可枚举属性，那些属性则会被拷贝。

- 注

	- 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
	- Object.assign 方法实行的是浅复制，而不是深复制。也就是说，如果源对象某个属性的值是对象，那么目标对象复制得到的是这个对象的引用，这个对象的任何编号都会反映到目标对象上。

		- 对于这种嵌套的对象，一旦遇到同名属性，Object.assign 的处理方法是替换而不是添加。
		- 有一些函数库提供 Object.assign 的定制版本（比如 Lodash 的 _.defaultsDeep 方法），可以解决浅复制的问题，得到深复制的合并。

	- Object.assign 可以用来处理数组，但是会把数组视为对象来处理。
	- Object.assign 方法总是复制一个属性的值，而不会复制它背后的赋值方法或取值方法。(get 和 set)

- 常见用途

	- 为对象添加属性
	- 为对象添加方法
	- 克隆对象

		- function clone(origin) {                                               
    return Object.assign({}, origin); }
		- 上面的代码将元素对象赋值到一个空对象中，就得到了原始对象的克隆。
		- 不过采用这种方法只能克隆原始对象自身的值，不能克隆它继承的值，如果想要保持继承链，可以使用下面代码实现
		- function clone(origin) {                                               
       let originProto = Object.getPrototype(origin);    
       return Object.assign(Object.create(originProto ), origin); }

	- 合并多个对象
	- 为属性指定默认值

### 属性的可枚举性

- 描述

	- 对象的每一个属性都具有一个描述对象(Descriptor)，用于控制该属性的行为。
	- Object.getOwnPropertyDescriptor 方法可以获取该属性的描述对象。
	- 描述对象的 enumerable 属性称为”可枚举性“，如果该属性为 false，就表示某些操作会忽略当前属性。

		- ES5 有 3 个操作会忽略 enumerable 为 false 的属性

			- for...in 循环：只遍历对象自身的和继承的可枚举属性。
			- Object.keys()：返回对象自身的所有可枚举属性的键名。
			- JSON.stringify()：只串行化对象自身的可枚举属性。

		- ES6 新增了 1 个操作 Object.assign()，会忽略 enumerable为 false 的属性，只赋值对象自身的可枚举属性。
		- 这 4 个操作中，只有 for...in 会返回继承的属性。

	- 实际上，引入 enumerable 的最初目的就是让某些属性可以规避掉 for...in 操作。

		- 比如，对象原型的 toString 方法以及数组的 length 属性，就可以通过这种手段而不会被 for...in 遍历到。

	- 另外，ES6  规定，所有 Class 的原型的方法都是不可枚举的。

- 示例

	- let obj = {foo: 123};  
Object.getOwnPropertyDescriptor(obj,'foo');

		- { value: 123, writable: true, enumerable: true, configurable: true }

- 总结

	- 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关系对象自身的属性。所以，尽量不要用 for...in 循环，而用 Object.keys() 代替。

### 属性的遍历

- 描述

	- ES6 一共 5 中方法可以遍历对象的属性。

- for...in

	- for...in 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。

- Object.keys(obj)

	- Object.keys 返回一个数组，包括对象自身的(不含继承的) 所有可枚举属性（不含 Symbol 属性）。

- Object.getOwnPropertyNames(obj)

	- Object.getOwnPropertyNames 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）

- Object.getOwnPropertySymbols(obj)

	- Object.getOwnPropertySymbols 返回一个数组，包含对象自身的所有 Symbol 属性。

- Reflect.ownKeys(obj)

	- Reflect.ownKeys 返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 还是字符串，也不管是否可枚举。

- 以上 5 种方法遍历对象的属性时都遵守同样的属性遍历次序规则。

	- 首先遍历所有属性名为数值的属性，按照数字排序。
	- 其次遍历所有属性名为字符串的属性，按照数字排序。
	- 最好遍历所有属性名为 Symbol 值的属性，按照生成时间排序。

### __proto__ 属性、Object.setPrototypeOf()、Object.getPrototypeOf()

- __proto__ 属性

	- 描述

		- __proto__ 属性（前后各两个下划线）用来读取或设置当前对象的 prototype 对象。目前，所有浏览器都部署了这个属性。
		- 该属性没用写入 ES6 的正文，而是写入了附录，原因是 __proto__ 前后的双下划线说明它本质上是一个内部属性，而不是一个正是的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。
		- 标准明确规定，只有浏览器必须部署这个属性，其他允许环境不一定要部署，而且新的代码最好认为这个属性是不存在的。
		- 因此，无论从语义的角度，还是兼容性的角度，都不要使用这个属性，而是使用 Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）或 Object.create()（生成操作）代替。
		- 如果一个对象本身部署了 __proto__ 属性，则该属性的值就是对象的原型。

	- 实现

		- __proto__ 调用的是 Object.prototype.__proto__ 。
		- 具体实现

		  Object.defineProperty(Object.prototype, '__proto__', { 
		  	get() {
		  		let _thisObj = Object(this);
		  		return Object.getPrototypeOf(_thisObj);
		  	},
		  	set(proto) {
		  		if (this === undefined || this === null) { 
		  			throw new TypeError();
		  		 }
		  		if (!isObject(this)) {
		  			return undefined;
		  		}
		  		if (!isObject(proto)) {
		  			return undefined;
		  		}
		  		let status = Reflect.setPrototypeOf(this, proto);
		  		if (!staus) {
		  			throw new TypeError();
		  		}
		  	},
		  });
		  function isObject(value) { 
		  	return Object(value) === value;
		  }

- Object.setPrototypeOf()

	- 描述

		- Object.setPrototypeOf 方法的作用与 __proto__ 相同，用来设置一个对象的 prototype 对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。

	- 格式

		- Object.setPrototypeOf(object, prototype)

	- 用法

		- var o = Object.setPrototypeOf({}, null);
		- 等同于
		- function(obj, proto){                                  
   obj.__proto__ = proto;                                                
   return obj; }
		- 如果第一个参数部署对象，则会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。
		- 由于 undefined 和 null 无法转为对象，所以如果第一个参数是 undefined 或 null，就会报错。

- Object.getPrototypeOf()

	- 描述

		- 该方法与 setPrototypeOf 方法配套，用于读取一个对象的 prototype 对象。

### Object.keys()、Object.values()、Object.entries()

- Object.keys()

	- 描述

		- ES5 引入了 Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历(enumerable) 属性的键名。
		- ES2017 有一个填，其中引入了与 Object.keys 配套的 Object.values 和 Object.entries 作为遍历一个对象的补充手段。

- Object.values()

	- 描述

		- Object.values() 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历(enumerable) 属性的键值。
		- 该方法会过滤属性名为 Symbol 值的属性。
		- 如果 Object.values 方法的参数是一个字符串，则会返回各个字符组成的一个数组。
		- 如果参数不是对象，Object.values 会先将其转为对象。由于数值和布尔值的包装对象都不会为示例添加非继承的属性，所以 Object.values 会返回空数组。

	- 补充

		- Object.create 方法的第二个参数添加的对象属性如果不是显式声明(没有使用属性描述对象写法)，默认是不可遍历的。因为添加的属性的属性描述对象的 enumerable 默认是 false，Object.values 不会返回这个属性。

- Object.entries

	- 描述

		- Object.entries 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历(enumerable) 属性的键值对数组。
		- Object.entries 方法的另一个用处是将对象转为真正的 Map 结构。

	- 补充

		- Object.entries 只输出属性名为非 Symbol 值的属性。将来可能会有 Reflect.ownEntries() 方法返回对象自身的所有属性。

### 对象的扩展运算符

- 描述

	- ES2017 将扩展运算符引入了对象。

- 解构赋值

	- 描述

		- 对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性分配到直到指定的对象上面。所有的键和他们的值都会复杂到新对象上面。

	- 示例

		- let {x,y,...z } = { x:1, y:2, a:3, b:4 };

			- x //1; y //2; z // {a:3, b:4};

	- 注

		- 解构赋值必须是最后一个参数，否则会报错。
		- 由于解构赋值要求等号右边是一个对象，所以如果等号右边是 undefined 或 null 就会报错，因为它们无法转为对象。
		- 解构赋值的复制是浅复制，即如果一个键的值是符合类型的值(数组、对象、函数)，那么解构赋值复制的是这个值的引用，而不是这个值的副本。
		- 解构赋值不会复制继承自原型对象的属性。

	- 用处

		- 扩展某个函数的参数，引入其他操作。

- 扩展运算符

	- 描述

		- 扩展运算符( ... ) 用于取出参数对象的所有可遍历属性，并将其复制到当前对象之中。

	- 示例

		- let aClone = { ...a };
		- 这等同于使用 Object.assign 方法

			- let aClone =  Object.assign({}, a);

		- 上面的例子只是复制的对象实例的属性，如果想完整克隆一个对象，还要复制对象原型的属性，可以采用以下方法。
		- 一：const clone1 = {                                              
 __proto__: Object.getPrototypeOf(obj),                         
  ...obj        };
		- 二：const clone2 = Object.assign(  
 Object.create(Object.getPrototype(obj)), obj );
		- 推荐写法二，写法一 的 __proto__ 属性在非浏览器的环境不一定部署。

### Object.getOwnPropertyDescriptors()

- 描述

	- ES5 的 Object.getOwnPropertyDescriptor 方法来返回某个对象属性的描述对象(descriptor)。
	- ES 2017 引入了 Object.getOwnPropertyDescriptors 方法，返回指定对象所有自身属性（非继承属性）的描述对象。
	- Object.getOwnPropertyDescriptors 方法返回一个对象，所有原对象的属性名都是该对象的属性名，对于的属性值就是该属性的描述对象。

- 用途

	- 该方法的引入主要是为了解决 Object.assign() 无法正确复制 get 属性和 set  属性的问题。

		- Object.assign 方法总是赋值一个属性的值，而不会赋值它背后的赋值方法或取值方法。
		- 该方法配合 Object.defineProperties 方法就可以实现正确复制。
		- 示例

			- const source = { set foo(value) { console.log(value); } }                                          
const target2 = {};  
Object.defineProperties(target2,Object.getOwnPropertyDescriptors(source));

		- Object.defineProperties 方法是在一个对象上定义一个或多个新的属性描述对象或修改现有属性，并返回该对象。

	- 配合 Object.create 方法将对象属性克隆到一个新对象。这属于浅复制。
	- 该方法也可以实现一个对象继承另一个对象

		- 以前的写法

			- const obj = { __proto__: prot, foo:123 };
			- const obj = Object.create(prot); obj.foo = 123;
			- const obj = Object.assign( Object.create(prot),{ foo: 123} )

		- const obj = Object.creat( prot,Object.getOwnPropertyDescriptors( { foo:123 }, ) );

	- Mixin(混入)模式

- 实现

  function getOwnPropertyDescriptors(obj) { 
  	const result = {}；
  	for(let key of Reflect.ownKeys(obj)) {
  		result[key] = Object.getOwnPropertyDescriptor(obj, key);
  	return  result;
  	}
  }

## Symbol

### 基本概述

- 描述

	- ES5 的对象属性名都是字符串，这容易造成属性名的冲突。如果有一种机制，能够保证每个属性的名字都是独一无二的就好了，这样就能从根本上防止属性名冲突。这就是 ES6 引入类型 Symbol 的原因。
	- ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第 7 种数据类型，前六种分别是：Undefined、Null、布尔值(Boolean)、字符串(String)、数值(Number)和对象(Object)。
	- Symbol 值通过 Symbol 函数生成。也就是说，对象的属性名可以有两种类型：一种是原来就有的字符串，另一种就是新增的 Symbol 类型。只要属性名属于 Symbol，就是独一无二的，可以保证不会与其他属性名产生冲突。

- 基本使用

	- Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时比较容易区分。

		- var s1 = Symbol('foo'); var s2 = Symbol('bar');
		- s1 // Symbol(foo)  s2 // Symbol(bar)
		- s1.toString() // "Symbol(foo)"

			- s2.toString() // "Symbol(bar)"

		- 如果不加参数，它们在控制台的输出都是 Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出时就能够分清到底是哪一个值。

	- 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。
	- Symbol 值不能与其他类型的值进行运算，否则会报错。
	- 但是，Symbol 值可以显式转为字符串。

		- var sym = Symbol('foo');
		- String(sym); // "Symbol(foo)"
		- sym.toString(); // "Symbol(foo)"

- 示例

	- let s = Symbol();

		- typeof s // “symbol”

- 注

	- Symbol 函数前不能使用 new 命令，否则会报错。这时因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。
	- Symbol 函数的参数只表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。

		- var s1 = Symbol('foo'); var s2 = Symbol('foo');

			- s1 === s2 // false

### 作为属性名的 Symbol

- 描述

	- 由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符用于对象的属性名，保证不会出现同名的属性。
	- 这对于一个对象由多个模块构成的情况非常有用，能防止某一个键不小心改写或覆盖。
	- Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。

		- 常量使用 Symbol 值的最大好处就是，其他任何值都不可能有相同的值了，因此可以保证 switch 语句按照涉及的方式工作。

- 示例

	- var mySym = Symbol();
	- 第一种写法

		- var a = {}; a[mySymbol] = 'Hello!‘;

	- 第二种写法

		- var a = { [mySymbol]: 'Hello!' };

	- 第三种写法

		- var a={}; Object.defineProperty(a, mySymbol,{value: 'Hello!'});

	- 上面的代码通过方括号结构和 Object.defineProperty 将对象的属性名指定为一个 Symbol 值。

- 注

	- Symbol 值作为对象属性名时不能使用点运算符。因为点运算符后面总是字符串，所以不会读取标识名所指代的值，导致属性名是一个字符串，而不是一个 Symbol 值。
	- 同理，在对象内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号中。

### 实例：消除魔术字符串

- 描述

	- 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或数值。风格良好的代码，应该尽量消除魔术字符串，而由含义清晰的变量替代。

- 示例

	- function getArea(shap, options){ var area = 0; 
    switch(shape) { case 'Triangle' : // 魔术字符串  
      area = xxxx; breal;  /*...more code ...*/ } 
    return  area; }

		- getArea('Triangle', { xx }); // 魔术字符串

	- 上面的代码中，字符串 'Triangle' 就是一个魔术字符串。它多次出现，与代码形成 “强耦合”，不利于将来的修改和维护。

- 解决办法

	- 常用的消除魔术字符串的方法，就是把它写成一个变量。(’Triangle‘ 用一个变量 triangle 表示)
	- 如果仔细分析，可以发现变量等于哪个值并不重要，只要确保不会和其他变量值冲突即可，因此这里就很适合用 Symbol 值。
	- const shapeType = { triangle: Symbol() };
	- case 匹配时： cast shapeType.triangle

## Set 和 Map 数据结构

### Set

- 描述

	- 1. 成员唯一  
	- 2.可遍历（遍历器）
	- 3. 成员结构：值—值（两者相同）
	- 4. 接受具有 Iterator 接口的结构作为构造参数
	- 5. 遍历顺序为插入顺序

- 属性

	- constructor
	- size

- 方法

	- add(value)
	- delete(value)
	- has(value)
	- clear()

- 遍历操作

	- keys()：返回键名的遍历器
	- values()：返回键值的遍历器
	- entries()：返回键值对的遍历器
	- forEach()：使用回调函数遍历每个成员（无返回值）

### WeakSet

- 与 Set 类似  差异：1. 成员只能为对象  2. 弱引用 3. 不可遍历
- 用处：适合临时存放一组对象，以及存放跟对象绑定的信息，只要外部引用消失，结构内部引用就会自动被垃圾回收清除。防止内存泄漏。
- 实际应用：1. 以 DOM 节点为键名，注册监听事件 2. 部署私有属性，内部属性使用 WeakMap 构建，如果删除实例，也会随之消失

### Map

- 描述

	- 1. 成员唯一（后来赋值会覆盖前值）
	- 2.可遍历（遍历器）
	- 3. 成员结构：键-值

		- 键类型不限于字符串，Object 的键只能为字符串）
		- 键与内存地址绑定，内存地址不一样（同名），视为两个键
		- 键为简单类型：严格相等则为一个键，包括0和-0，NaN也为同个键

	- 4. 接受具有 Iterator 接口的结构作为构造参数
	- 5. 遍历顺序为插入顺序

- 属性

	- 与 Set 类似

- 方法

	- 与 Set 类似（设置获取方法不同）
	- get(key)
	- set(key, value)

### WeakMap

- 与 WeakSet 同理

## Proxy

### 概述

- 用于修改某些操作的默认行为，提供了一种机制可以对外界的访问进行过滤和改写——“代理器”
- 生成 Proxy 实例: new Proxy(target, handler);

	- target: 要拦截的目标对象
	- handler: 定制拦截行为
	- 注：要使 Proxy 起作用，必须针对 Proxy 实例进行操作，而不是针对目标对象（target）进行操作。

### 方法

- get

	- 描述: 用于拦截某个属性的读取操作
	- 参数: target, property,recevier(可选)
	- 应用

		- 利用 get 可以将读取属性的操作转变为执行某个函数，从而实现属性的链式操作。
		- 利用 get 拦截实现一个生成各种 DOM 节点的通用函数

- set

	- 描述: 用于拦截某个个属性的赋值操作
	- 参数: target, property, , recevier(可选)
	- 应用

		- 利用 set 方法实现数据绑定，每当对象发生变化时，自动更新DOM（还未寻求答案）
		- 利于 set 保证被代理对象的属性值符合要求
		- 结合 get 和 set 方法可以防止对象内部属性（下划线开头 ' _ '）被外部读/写。

	- 注: 如果目标对象自身的某个属性不可写也不可配置,那么 set 不得改变这个属性的值,只能返回同样的值,否则报错

- apply

	- 描述: 拦截函数的调用、call 和 apply 操作
	- 参数: target, thisArg(目标对象的上下文(this)), args(目标对象的参数数组)

- has

	- 描述: has 方法用来拦截 HasProperty 操作(判断对象是否具有某个属性)
	- 应用: 隐藏某些属性,使其不被 in 运算符发现 ( 对 for...in 无效)

- constuct

	- 描述: 用于拦截 new 命令,必须返回对象
	- 参数: target, args

- deleteProperty

	- 描述: 用于拦截 delete 操作,当该对象抛出错误或返回 false 则当前属性无法被 delete 命令删除
	- 注: 目标对象自身的不可配置(configurable)的属性不能被该方法删除,否则会报错

- defineProperty

	- 描述: 用于拦截 Obect.defineProperty 操作(在一个对象上定义一个新属性,或者修改一个对象的现有属性)
	- 注: 若对象不可扩展(extensible), 则 defineProperty 不能增改加目标对象中不存在的属性,否则会报错。如果目标对象的某个属性不可写(writable) 或不可配置(configurable),则 defineProperty 方法不得改变这两个设置。

- getOwnPropertyDescriptor

	- 描述：拦截 Object.getOwnPropertyDescriptor 操作(该方法返回指定对象上的一个自有属性对应的属性描述符)，返回一个属性描述对象或 undefined

- getPrototypeOf

	- 描述: 用来拦截获取对象原型。

		- Object.prototype.__proto__: 访问器属性，通过它访问对象内部的[[Prototype]] (推荐使用 Object/Reflect.getPrototypeOf)
		- Object.prototype.isPrototypeOf()：检验一个对象是否在另一个对象的原型链上。
		- Object.getPrototypeOf()：返回指定对象的原型（内部[[Prototype]]的值）
		- Reflect.getPrototypeOf(): 上同
		- instanceof：检查构造函数的 prototype 属性是否在某个实例对象的原型链上。

	- 注：该方法返回值必须是对象或 null，否则会报错。另外，如果目标对象不可扩展（extensible), 该方法必须返回目标对象的原型对象。

- setPrototype

	- 描述: 用于拦截 Object.setPrototypeOf 方法(设置一个指定的对象的原型，即内部的[[Prototype]]到另一个对象，使用Object.create()来创建带有想要[[Prototype]]的新对象更好）

- isExtensible

	- 描述: 用来拦截 Object.isExtensible 操作(判断一个对象是否可扩展的(是否可以在它上面添加新的属性))，只能返回布尔值，否则返回值会被自动转换布尔类型。
	- 注：强限制，返回值必须与目标对象的 isExtensible 属性保持一致，否则会报错。

- ownKeys

	- 描述: 用来拦截对象自身属性的读取操作,返回的数组成员只能是字符串或 Symbol 值。

		- Object.getOwnPropertyNames(): 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。
		- Object.getOwnPropertySymbols(): 返回一个给定对象自身的所有 Symbol 属性的数组。
		- Object.keys(): 返回一个由一个给定对象的自身可枚举属性组成的数组。

	- 注： 使用 Object.keys 时，目标上不存在的属性、属性名为 Symbol 值、不可遍历(enumerable)的属性会被该方法过滤。如果目标对象自身包含不可配置的属性，则该属性必须被该方法返回。如果目标对象是不可扩展的，返回的数组中必须含有原对象的所有属性，且不能包含多余的属性。

- preventExtensions

	- 描述: 用于拦截 Object.preventExtensions 操作(该方法让一个对象变的不可扩展，也就是永远不能再添加新的属性)，必须返回一个布尔值，否则会被自动转换为布尔值。
	- 注: 限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false ,该方法才能返回 true。

- Proxy.revocable

	- 描述: 返回一个可取消的 Proxy 实例
	- 应用

		- 目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。

### this问题

- 问题：虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下也无法保证与目标对象的行为一致。主要原因就在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代，此外，有些原生对象的内部属性只有通过正确的this才能获取（例如getDate），所以Proxy 也无法代理
- 解决：this 绑定原始对象就可以解决这个问题，例如: 在get 方法内 target.xxx.bind(target);

## Reflect

### 描述

-  将 Object 对象的一些明属于语言内部的方法（比如 Object.defineProperty) 放到 Reflect 对象上，未来的新方法将只在 Reflect 对象上部署，即从 Reflect 可对象上可以获得语言内部的方法
- 修改某些 Object 方法的返回结果，其变更合理。
- 让 Object 操作都变成函数行为，某些 Object 操作是命令式，例如 in 和 delete 操作 -- Relfect.has(obj, name) 和 Reflect.deleteProperty(obj, name)
- Reflect 对象的方法与 Proxy 对象的方法一一对应，这使得 Proxy 对象可以方便地调用对应的 Reflect 方法来完成默认行为，作为修改行为的基础。也就是说，无论 Proxy 怎么修改默认行为，我们总可以在 Reflect 上获取默认行为。

### 方法

- 注：大部分方法，如果第一个目标对象参数不是对象，会报错。Object 行为不同方法不一样
- Reflect.get(target, name, recevier)

	- 描述; 查找并返回 target 对象的 name 属性，若无则返回undefined
	- 注：若 name 属性部署了读取函数（getter），则读取函数的 this 绑定 receiver(接收者); 

- Reflect.set(target, name, value, recevier)

	- 描述: 设置 target 对象的 name 属性等于 value
	- 注：若 name 属性部署了赋值函数（setter），则读取函数的 this 绑定 receiver(接收者);  Reflect.set 会触发 Proxy.defineProperty 拦截。

- Reflect.has(obj, name)

	- 描述: 对应 `name in obj` 中的 in 运算符

- Reflect.deleteProperty(obj, name)

	- 描述: 对应 `delete obj[name]`，用于删除对象的属性。如果删除成功或被删除的属性不存在，就返回 true；如果删除失败或者被删除的属性依然存在，返回 false。

- Reflect.construct(target, args)

	- 描述: 等同于 `new target(...args)`，提供了一种不使用 new 来调用构造函数的方法。

- Reflect.getPrototypeOf(obj)

	- 描述: 用于读取对象的 __proto__ 属性，对应 Object.getPrototypeOf(obj)。
	- 注: 如果参数不是对象 Object.getPrototypeOf 会把参数转为对象，再运行，而 Reflect.getPrototypeOf 会报错。

- Reflect.setPrototypeOf(obj, newProto)

	- 描述: 用于设置对象的 __proto__ 属性，返回第一个参数对象，对应 Object.setPrototypeOf(obj, newProto)。

- Reflect.apply(func, thisArg, args)

	- 描述: 等同于 `Function.prototype.apply.call(func, thisArg, args)`, 用于绑定 this 对象后执行给定函数。
	- 如果要绑定一个函数的 this 对象，可以写成 fn.apply(obj, args) 的形式，但是如果函数定义了自己的 apply 方法，那么就只能写成 Function.prototype.apply.call(fn, obj, args)的形式，采用 Reflect 对象可以简化这种操作。

- Reflect.defineProperty(target, propertyKey, attributes)

	- 描述: 基本等同于 Object.defineProperty，用来为对象定义属性。今后，后者会被逐渐废除，因此从现在开始请使用 Reflect.defineProperty 来代替它。

- Reflect.getOwnPropertyDescriptor(target, propertyKey)

	- 描述: 基本等同于 Object.getOwnPropertyDescriptor, 用于指定属性的描述对象，将来会替代后者。

- Reflect.isExtensible(target)

	- 描述: 对应 Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。

- Reflect.preventExtensions(target)

	- 描述: 对应 Object.preventExtensions 方法，用于使一个对象变为不可扩展的。返回一个布尔值，表示是否操作成功。

- Reflect.ownKeys(target)

	- 描述: 用于返回对象的所以属性，基本等同于 Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和。

### 实例

- 使用 Proxy 实现观察者模式

	- 描述：观察者模式（Observer mode）指的是函数自动观察数据对象的模式，一旦对象有变化，函数就会自动执行。

## Promise

### 描述

- Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件更合理且更强大(解决回调地狱问题)。简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。

### 对象特点

- 对象的状态不收外界影响，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。“Promise”——承诺，表示其他手段无法改变。

	- Pending(进行中)
	- Fulfilled(已成功)
	- Rejected(已失败)

- 一旦状态改变就不会再变，改变后任何时候都可以得到这个结果。Promise 对象的状态改变只有两种可能：从 Pending 变为 Fulfilled 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变，而是一直保持这个结果，这时就称为 Resovled (已定型)。

### 缺点

- 无法取消 Promise , 一旦新建它就会立刻执行，无法中途取消。
- 如果不设置回调函数，Promise 内部抛出的错误不会反应到外部。
- 当处于 Pending 状态时，无法得知目前进展到哪一个阶段（是刚刚开始还是即将完成）。

### 基本使用

- Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject，它是两个函数用来改变 Promise 对象的状态

	- var promise = new Promise(function (resolve, reject) {})

- Promise 实例生成以后，可以用 then 方法分别指定 Resolved 状态 和 Rejected 状态的回调函数。

	- promise.then(function(value){}, function(value){})

- 注：then 方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行，Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。

### 方法

- then

	- 描述：

		- 作用是为 Promise 实例添加状态改变时的回调函数。then方法可以接受两个回调函数作为参数，第一个是对象状态变为 Resolved 时调用，第二个(可选)是对象状态变为 Rejected 时调用。这两个函数都接受 Promise 对象的传出值作为参数。
		- then 方法返回的是一个新的 Promise，所以可以采用链式写法，即 then 方法后面再调用另一个 then 方法。前一个 then 返回的可能还是一个 Promise 对象(即有异步操作)，后一个 then 的回调函数就会等待该对象状态发生变化再调用

- catch

	- 描述：

		- 用于指定发生错误时的回调函数，等同于 .then(null, rejection) 的别名。如果异步操作抛出错误，状态就会变为 Rejected，然后调用 catch 方法指定的回调函数处理这个错误。
		- Promise 对象的错误具有"冒泡"性质，会一致向后传递直到被捕获位置，也就是说，错误总会被下一个 catch 语句捕获

	- 注：then 方法指定的回调函数如果在运行中抛出错误，也会被catch 捕获；最好不要在 then 方法定义 Rejected 状态的回调函数( 即 then 的第二个参数) , 而应选择 catch 方法。

- resolve

	- 描述：

		- 将现有对象转换为 Promise 对象

	- 参数

		- 参数是一个 Promise 实例，不做任何修改，原封不动地返回这个实例
		- 参数是一个 thenable 对象（指具有 then 方法的对象）, 该方法会将这个对象转为 Promise 对象，然后立即执行 thenable 对象的 then 方法 
		- 参数不是具有 then 方法的对象或根本不是对象，那么该方法返回一个新的 Promise 对象，状态为 Resolved
		- 不带有任何参数，直接返回一个 Resolved 状态的 Promise 对象

- reject

	- 描述：

		- 返回一个新的 Promise 实例，状态为 Rejected

	- 注：Promise.reject() 方法的参数会原封不动地作为 reject 的理由变成后续方法的参数。

- all

	- 描述：

		- 用于将多个 Promise 实例包装成一个新的 Promise 实例，该方法接受一个具有 Iterator 接口的对象作为参数。若参数成员不为 Promise 实例，则调用 Promise.resolve 方法将参数转为 Promise 实例

			- var p = Promise.all([p1, p2, p3]);

	- 实例状态：

		- 只有参数对象成员的实例状态都变成 Fulfilled，该 Promise 实例的状态才会变成 Fulfilled，此时参数对象的成员的返回值组成一个数组，传递给该实例的回调函数。
		- 只要参数对象的成员中实例有一个被 Rejected，该 Promise 实例状态就会变成 Rejected，此时第一个被 Rejected 的参数成员的返回值会传递给该实例的回调函数。

	- 注：如果作为参数的 Promise 实例自身定义了 catch 方法，那么它被 rejected 时并不会触发 Promise.all() 的catch 方法。

- race

	- 描述：

		- 该方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。区别在于实例状态改变所依据的不同。若参数成员不为 Promise 实例，则调用 Promise.resolve 方法将参数转为 Promise 实例。

	- 实例状态：

		- 只要参数对象的成员中有一个状态率先改变状态，Promise 实例状态就会改变，此时那个率先改变的参数成员的实例的返回值会传递给该实例的回调函数。

### 附加方法

- done

	- 描述：

		- 无论 Promise 对象的回调链以 then 方法还是 catch 方法结尾，只要最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。为此，可以提供一个 done 方法，他总处于回调链的尾端，保证抛出任何可能出现的错误

	- 实现代码

		- 待整理

- finally

	- 描述：

		- finally 方法用于指定不管 Promise 对象最后状态如何都会执行的操作。它与 done 方法的最大区别在于，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。

### 应用

- 加载图片

	- 将图片的加载写成一个 Promise，一旦加载完成，Promise 的状态就发生变化。

		- 待整理

- Generator函数与 Promise 的结合

	- 未读

### Promise.try()

- 描述：

	- 无需区分执行函数是同步还是异步操作，都可以用Promise.try()

- 实现

	- 使用 async 函数也能实现同样功能
	- 使用立即执行的匿名函数来执行 new Promise()

- 注：只是一个提案

## for...of 

### 描述：

- 一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for...of 循环遍历它的成员。也就是说，for...of 循环内部调用的是数据结构的 Symbol.iterator 方法

### 使用范围：

- 数组

	- for...of 循环可以代替数组实例的 forEach 方法
	- 如果要通过 for...of 循环获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法。
	- 数组的遍历器接口只返回具有数字索引的属性。

- Set 和 Map 结构

	- 遍历的顺序是按照各个成员被添加进数据结构的顺序；其次，Set数据结构遍历时返回的时一个值，而 Map 结构遍历返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。

- 某些 类似数组的对象(比如 arguments 对象、DOM NodeList 对象)
- Generator 对象
- 字符串

	- 可以正确识别 32 位 UTF-16 字符

### 作用

- JS原有的 for...in 循环只能获得对象的键名，不能直接获取键值。ES6 提供的 for...of 循环允许遍历获得键值。

### 注：

- 对于普通对象，一种解决办法是，使用 Object.keys 方法将对象的键名生成一个数组，然后再用 for...of 遍历这个数组，另一种是使用 Generator 函数将对象重新包装一下

### 与其他遍历方法比较

- for：较为繁琐
- forEach：无法中途跳出 forEach 循环, break 命令或 return 命令都不能生效。
- for...in

	- 缺点

		- 数组d的键名是数字，但是 for...in 循环是以字符串作为键名，"0"、"1"、"2"
		- for...in 循环不仅可以遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
		- 某些情况下，for...in 循环会以任意顺序遍历键名。

	- 注：for...in 循环主要是为遍历对象而设计的，不适用遍历数组。

- for...of

	- 相比较之的优点

		- 有着 for...in 一样的简洁语法，但是没有 for...in 那些缺点。
		- 不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。
		- 提供了遍历所有数据结构的统一操作接口

## Iterator

### 描述

- 遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构，只要部署 Iterator 接口，就可以完成遍历操作（即以此处理该结构的所有成员）。

### 作用

- 为各种数据结构提供一个统一的、简便的访问接口
- 使得数据结构的成员能够按照某种次序排列
- ES6创造了一种新的遍历命令—— for...of 循环，Iterator 接口主要提供 for...of 消费。（也可以使用 while 循环）

### 遍历过程

- 每次调用 next 方法都会返回数据结构的当前成员的信息，具体来说就是返回一个包含 value 和 done 两个属性的对象。value 是当前成员的值，done 是表示遍历是否结束( 布尔值 )。

	- { value: xx, done: false }  遍历完成 { value: undefined, done: true } 

- 创建一个指针对象，指向当前数据结构的起始位置。（遍历器对象本质上就是一个指针对象）。
- 第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员
- 第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员
- 不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。

### 默认 Iterator 接口

- 描述：

	- 默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说一个数据结构只要句有 Symbol.iterator 属性，就可以认为是“可遍历的”(iterable)。调用 Symbol.iterator 方法，可以得到当前数据结构默认的遍历器生成函数，Symbol.iterator 本身是一个表达式，返回 Symbol 对象的 iterator 属性。

- 具有默认遍历器接口的数据结构

	- Array
	- Map
	- Set
	- String
	- TypeArray
	- 函数的 arguments 对象
	- NodeList 对象(部分类数组对象)

- 注：

	- 其他数据结构（主要是对象）的 Iterator 接口都需要自己在 Symbol.iterator 属性上面部署，这样才会被 for...of 循环遍历，之所以没有默认部署 Iterator 接口，是因为对象属性的遍历先后顺序是不确定的，需要开发者手段指定
	- 本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口就等于部署一种线性转换。不过，严格的说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES6原生提供了。

### 遍历器对象的方法

- 描述：

	- 若自己写遍历器对象生成函数，那么next 方法是必须部署的，return 方法 和 throw 方法则是可选部署的

- return

	- 使用场合是，如果 for...if 循环提前退出（通常是因为出错或者有 break 语句或 continue 语句），就会调用 return 方法；如果一个对象在完成遍历前需要请理或释放资源，就可以部署 return 方法

- throw

	- 配合Generator 函数使用

### 部署 Iterator 接口

- 可以在构造函数的原型链上部署 Symbol.iterator 方法，调用该方法会返回遍历器对象 iterator，调用该对象的 next 方法，在返回一个值的同时自动将内部指针转移到下一个实例。
- 对于类似数组的对象（存在数值键名和 length 属性），部署 Iterator 接口有一个简便的方法，即使用 Sysmbol.iterator 方法直接引用数组的 Iterator 接口。注意，普通对象部署数组的 Symbol.iterator 方法并无效果。
- Symbl.iterator 方法的最简单实现使用 Generator 函数
- 对于没有具有 Iterator 接口的类似数组的对象，一个简便的解决方法就是使用 Array.from 方法将其转为数组。

### 使用场合

- 对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。
- 扩展运算符（ ... ) 也会调用默认的 Iterator 接口。
- yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口
- 其他场合

	- for...of
	- Array.from
	- Map()、Set()、WeakMap()、WeakSet() (如 new Map(['a',1], ['b',2])
	- Promise.all() / Promise.race()

## Generator

### 描述：

- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
- 从语法上，首先把它理解成一个状态机，封装了多个内部状态。其次执行 Generator 函数会返回一个遍历器对象（也就是 Generator 也是一个遍历器对象生成函数），返回的遍历器对象可以依次遍历 Generator 函数内部的每一个状态。
- 从形式上，Generator 函数是一个普通函数，但是有两个特征

	- 一是 function 命令与函数名之间有一个星号 * （写在 function 关键字和函数名之间即可）
	- 二是函数体内部使用 yield 语句定义不同的内部状态(yield—产出)

- Generator 可以生成一系列的值，名称的来历——“生成器”
- function* generatorFunction() {}

### 语法

- 调用方法

	- Generator 函数的调用方法也是在函数名后加一对圆括号，不同的是，调用后该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（ Iterator Object）。
	- 下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行,直到遇到下一条 yield 语句（或 return 语句）为止。
	- 每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 表示当前内部状态(yield语句后面表达式的值)的值，done 属性是一个布尔值，表示是否遍历结束
	- 简单来说，Generator 函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行。

- yield 表达式

	- 描述：

		- 暂停标志（只允许用在 Generator 函数内）

	- yield 与 return

		- 相似之处在与都能返回紧跟在语句后的表达式的值。
		- 区别在于每次遇到 yield 函数暂停执行，下一次会从该继续向后执行，而 return 语句不具备位置记忆的功能。
		- 一个函数内只能执行依次（或者说一条）return 语句，但是可以执行多次（或者说多条）yield 语句。

	- Generator 函数可以不用 yield 语句，这时就变成了一个单纯的暂缓执行函数，只有调用 next 方法才会执行。
	- 注：

		- 正常函数只能返回一个值，因为只能执行一次 return 语句；Generator 函数可以返回一系列的值，因为可以有任意多条 yield 语句。
		- yield 表达式如果用在另一个表达式之中，必须放在圆括号里面，用作函数参数或放在赋值表达式的右边，可以不加括号。

			- console.log('11' + (yield 123)); | let input = yield;

- yield* 表达式

	- 描述

		- 可以在 Generator 函数内部调用另一个 Generator 函数
		- 从语法角度看，如果 yield 命令后面跟的是一个遍历器对象，那么需要在 yield 命令后面加上星号，表明返回的是一个遍历器对象，这被称为 yield* 语句。

	- 注

		- yield* 后面的 Generator(没有return 语句时) 等同于在 Generator 函数内部部署一个 for... of 循环。
		- 任何数据结构只要有 Iterator 接口，就可以被 yield* 遍历。
		- 如果被代理的 Generator 函数有 return 语句，那么可以向代理它的 Generator 函数返回数据。

	- 应用

		- 取出嵌套数组的所有成员（待整理）
		- 遍历完全二叉树（待整理）

- next 方法

	- next 运行逻辑

		- 遇到 yield 语句就暂停执行后面的操作，并将紧跟在 yield 后的表达式的值作为返回的对象的 value 属性值。
		- 下一次调用 next 方法时再继续往下执行，直到遇到下一条 yield 语句
		- 如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句位置，并将 return 语句后面的表达式的值作为返回对象的 value 属性值。
		- 如果该函数没有 return 语句，则返回对象的 value 属性值为 undefined。
		- 注：只有调用 next 方法且内部指针指向该语句才会执行 yield 语句后面的表达式，因此等于为 JavaScript 提供了手动的“惰性求值”	(Lazy Evaluation) 的语法功能。

	- 参数

		- yield 语句本身没有返回值，或者说总是返回 undefined，next 方法可以带有一个参数，该参数会被当作上一条yield 语句的返回值。
		- 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，其上下文状态(context) 是不变的。通过next 方法的参数就有办法在 Generator 函数开始运行后继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段从外部向内部注入不同的值，从而调整函数行为
		- 注：第一次使用 next 方法是传递参数是无效的(因为没有上一条 yield 表达式)，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。

- Generator.prototype.throw

	- 描述

		- Generator 函数体外抛出的错误可以在函数体内捕获，函数体内抛出的错误也可以被函数体外的 catch 捕获。

	- 参数

		- 接受y一个参数，该参数会被 catch 语句接收（建议抛出 Error 对象的实例。

	- 注：

		- 不要混淆遍历器对象的 throw 方法和全局的 throw 命令。全局的 throw 命令抛出的错误只能被函数体外的 catch 语句捕获。
		- 若 Generator 函数内部没有部署 try...catch 代码块，那么 throw 方法抛出的错误将被外部 try...catch 代码块捕获。
		- 若 Generator 函数内部部署了 try...catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历，否则遍历直接终止。
		- throw 方法捕获以后会附带执行下一条 yield 表达式，即附带执行一次 next 方法。

- Generator.prototype.return

	- 描述

		- 可以返回给定的值，并终结 Generator 函数的遍历。

	- 注

		- 若函数体内有 try...finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行。

- for...of 循环

	- 描述

		- 可以自动遍历 Generator 函数生成的 Iterator 对象，且此时无需调用 next 方法。

	- 终止条件

		- 一旦 next 方法的返回对象的 done 属性为true，循环就会终止，且不包含该返回对象。

- 作为对象属性

	- 简写为 let obj = { * gMethod(){} }

		- 等价于 let obj={ gMethod: function* (){} }

- Generator 函数 this

	- this 指向 Generator 函数返回的遍历器实例
	- Generator 函数不能跟 new 命令一起使用
	- 可以使用 call 方法让一个对象绑定 Generator 内部的 this，这样函数调用后，这个对象就是 Generator 函数的实例对象了。
	- 例子：改造成构造函数（待整理）

### 应用

- 实现状态机
- 作为协程使用
- 异步操作的同步化表达

	- 通过 Generator 部署 AJAX，可以用同步方式表达

- 控制流管理

	- 把回调函数(回调地狱)改成直线执行的形式，相比 Promise 进一步改善。

- 部署 Iterator 接口
- 作为数据结构

	- 因为 Generator 函数可以返回一系列的值，这以为着它可以对任意表达式提供类似数组的接口，使得数据和操作具备类似数组的接口。

### 异步应用

- ES6之前，异步编程方法

	- 回调函数

		- 描述

			- 所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务时便直接调用这个函数。回调函数的英文名叫 callback——“重新调用”

		- 注：

			- Node 约定回调函数的第一个参数必须是错误对象 err（如果没有错误，该参数就是 null）的原因是，执行分成两段，第一段执行以后，任务所在的上下文环境就已经结束了。在这之后抛出的错误，其原来的上下文环境已经无法捕捉了，只能当作参数传入第二段。

	- 事件监听
	- 发布/订阅
	- Promise 对象

		- 描述

			- 当异步操作多重嵌套，代码不是纵向发展，而是横向发展，导致乱成一团无法管理，因为多个异步操作形成了强耦合，只要有一个操作要修改，它的上层会调函数和下层回调函数都要跟着修改。这种情况就称为“回调函数地狱”(callback hell)。
			- Promise 对象就是为了解决这个问题而被提出的。它不是新的语法功能，而是一种新的写法，允许将会调函数的嵌套改成链式调用。

		- 问题

			- Promise 的最大问题是代码冗余，原来的任务被 Promise 包装之后，无论上面操作，一眼看上去都是许多 then 的堆积，原来的语义变得很不清除。

- 异步

	- 描述

		- 所谓“异步”，简单来说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好准备后再回头执行第二段。
		- 例如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读文件。然后程序执行其他任务，等到操作系统返回文件后再接着执行任务的第二段（处理文件），这种不连续的执行就叫作异步。
		- 相应的，连续执行叫作同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段事件，程序只能等待。

- Generator 函数

	- 了解协程

		- 传统的编程语言中早有异步编程的解决方案（其实是多任务的解决方案），其中一种叫作"协程"(coroutine)，意思是多个线程互相协作，完成异步任务。
		- 协程有点像函数，又有点像线程。运行流程大致如下

			- 第一步，协程A开始执行。
			- 第二步，协程A执行到一半，进入暂停状态，执行权转移到协程B中。
			- 第三步，（一段时间后）协程B交还执行权
			- 第四步，协程A恢复执行。

	- 特点

		- Generator 函数是协程在 ES6 中的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。
		- 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方都用 yield 语句注明。
		- Generator 可以暂停执行和恢复执行，是它能封装异步任务的根本原因。除此之外，还有两个特性使它可以作为异步编程的完整解决方案：

			- 函数体内外的数据交换

				- next 返回值的 value 属性是向函数体外输出数据
				- next 方法可以接受参数，向函数体内输入数据

			- 错误处理机制

		- 虽然 Generator 函数将异步操作表示得很简介，但流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。

	- 自动流程管理

		- Thunk 函数

			- 了解参数的求值策略，即函数的参数到底该在何时求值

				- "传值调用"(call by value)，即在进入函数体之前就计算参数表达式的值。C语言就采用这种策略。
				- "传名调用"(call by name)，即直接将参数表达式传入函数体内，只在用到它的时候求值。Haskell 语言采用这种策略。
				- 注：各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没有用到这个参数，有可能会造成性能损失。

			- 描述

				- 编译器的"传名调用"的实现往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就称为 Thunk 函数。（是"传名调用"的一种实现策略，可以用来替换某个表达式）。

			- JS的 Thunk 函数

				- 描述：JS语言是传值调用，它的 Thunk 函数含义有所不同。在JS中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。

					- fs模块的 readFile 方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它编程了一个单参数函数，只接受回调函数作为参数，这个单参数版本就叫 Thunk 函数。

				- 简单的 Thunk 函数转换器

					- ES5版本

					- ES6版本

					- 利用上面的转换器，生成 fs.readFile 的Thunk 函数。

				- Thunkify 模块

					- 安装：$ npm install thunkify
					- 使用方式

					- 源码

				- 基于 Thunk 函数的 Generator 执行器

					- 描述：自动执行 Generator函数，不管内部有多少个异步操作，直接把 Generator 函数传入 run 函数即可。前提是每一个异步操作都要是 Thunk 函数，也就是说，跟在 yield 命令后面的必须是 Thunk 函数。
			- 注：Thunk 函数并不是 Generator 函数自动执行的唯一方案，因为自动执行的关键是，必须有一种机制自动控制 Generator 函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。

		- 基于Promise 对象的自动执行

			- 沿用上面的 fs 模块把 readFile 方法包装成一个 Promise 对象

			- Generator 函数

			- 手动执行其实就是用 then 方法层层添加回调函数

			- 自动执行器

		- co 模块

			- 描述

				- 使用 co 模块无需编写 Generator 函数的执行器

					- var co = require('co');   co(gen);

				- co 函数返回一个 Promise对象，因此可以用 then 添加回调函数。（等待 Generator 函数执行结束后）

			- 原理

				- Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，这种机制要自动交回执行权。有两种方法可以做到这一点

					- 回调函数——将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。
					- Promise 对象——将异步操作包装成 Promise 对象，用then 方法交回执行权。

				- co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象包装成一个模块。使用co 的前提条件是，Generator 函数的 yield 命令后面只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员全部都是 Promise 对象，也可以使用 co。

			- 注：co v4.0版本以后，yield 命令后只能是 Promise 对象，不再支持 Thunk 函数
			- 源码

				- 首先 co 函数接收 Generator 函数作为参数，返回一个 Promise 对象

				- 在返回的 Promise 对象里面，co先检查参数 gen 是否为 Generator 函数，若是，就执行该函数，得到一个内部指针，若不是就返回，并将 Promise 对象的状态改为 resolved。

				- 接着，co 将 Generator 函数的内部指针对象的 next 方法包装成 onFulfilled 函数，这主要是为了能够捕获抛出的错误。

				- next函数，反复调用自身

			- 应用

				- 处理并发的异步操作（即允许某些操作同时进行，等到它们全部完成才进行下一步。）要把并发的操作都放在数组或对象中，跟在 yield 语句后面。

## Async

### 描述

- Generator函数的语法糖，使得异步操作更加方便，async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await，async 函数的改进体现在以下四点：

	- 1. 内置执行器；Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行和普通函数一模一样。
	- 2. 更好的语义；async 和 await 比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。
	- 3. 更广的适用性；co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这是等同于同步操作）。
	- 4. 返回值是 Promise；async 函数的返回值是 Promise 对象。这比 Generator 函数的返回值是 Iterator 对象方便了许多，可以用 then 方法指定下一步的操作。

- 进一步说，async 函数完全可以看作是由多个异步操作包装而成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。

### 用法

- async 函数返回一个 Promise 对象，可以使用 then 方法添加一个回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成后，再接着执行函数体后面的语句。
- 使用形式

	- 函数声明：async function foo() {}
	- 函数表达式：const foo = async function () {};
	- 对象的方法：let obj = { async foo() {} };   obj.foo().then(...)
	- class 的方法：class Xxx { constructor(){} async xxx(){} };
	- 箭头函数：const foo = async () => {};

### 语法

- 返回 Promise 对象

	- async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。
	- async 函数内部抛出错误会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。

- Promise 对象的状态变化

	- aysnc 函数返回的 Promise 对象必须等到内部所有 await 命令后面的 Promise 对象执行完才会发生状态改变，除非遇到 return 语句或抛出错误。也就是说，只有 async 函数内部的异步操作执行完毕，才会执行 then 方法指定的回调函数。

- await 命令

	- 正常情况下，await 命令后面是一个 Promise 对象，若不是，则会被转成一个立即 resolve 的 Promise 对象。
	- await 命令后面的 Promise 对象如果变为 reject 状态，则 reject 的参数会被 catch 方法的回调函数接收到。
	- 只要一个 await 语句后面的 Promise 变为 reject，那么整个 async 函数都会中断执行。若希望即使前一个异步操作失败，也不要中断后面的异步操作的方法是：

		- 可以将第一个 await 放在 try...catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。
		- await 后面的 Promise 对象添加一个 catch 方法，先处理前面可能出现的错误。

- 错误处理

	- 如果 await 后面的异步操作出错，那么等同于 async 函数返回的 Promise对象被 reject。

- 使用注意点

	- 因为await 命令后面的 Promise 对象的运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。
	- 多个 await 命令后面的异步操作如果不存在继发关系，最好让它们同时触发。

		- forEach循环会使得 await 后面的操作并发执行，即同时执行，而不是继发执行，若要继发执行则使用 for 循环。
		- 希望多个请求并发执行，可以使用 Promise.all 方法

	- await 命令只能用在 async 函数之中，如果用在普通函数中就会报错。

### 与其他异步处理方法的比较

- Promise 写法虽然比回调函数的写法大大改进，但是代码完全是 Promise 的 API（theb、catch等），操作本身的语义反而不容易看出来
- Generator 函数语义比 Promise 写法更清晰，用户定义的操作会全部出现在 Generator 函数内部。但是，必须有一个任务执行器自动执行 Generator 函数。
- async 函数的实现最简洁，最符合语义，几乎没有与语义不相关的代码。它将 Generator 写法中的自动执行器改在语言层面提供，不暴露给用户，因此代码量最少。

### 实现原理

- async 函数的实现原理就是将 Generator 函数和自动执行器包装在一个函数里

### 实例

- 按顺序完成异步操作

### 异步遍历器

- 描述

	- 为y异步操作提供原生的遍历器接口，即 value 和 done 这两个属性都是异步产生的，这称为“异步遍历器”（Async Iterator）

## Class

### 描述

- JavaScript 语言的传统方法是通过构造函数定义并生成对象
- ES6 中的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰，更像面对对象编程的语法而已。

### 基本语法

- 描述

	- 定义一个"类"，里面有一个 constructor 方法，这是构造方法，而 this 关键字则代表实例对象

	- 类的数据类型就是函数，类本身就指向构造函数。使用的时候也是直接对类使用 new 命令，跟构造函数的用法完全一致。

	- 构造函数的 prototype 属性在 ES6 的"类"上继续存在。事实上，类的所有方法都定义在类的 prototype 属性上。在类的实例上调用方法，其实就是调用原型上的方法。
	- 类的新方法可以添加在 prototype 对象上。Object.assign 方法可以很方便的一次向类添加多个方法。类的内部定义的所有方法都是不可枚举的(non-enumerable)。(可用Object,getOwnPropertyNames方法获取)
	- 与函数一样，Class也可以使用表达式的形式定义（const myClass = class { }），类的属性名可以采用表达式。

- 严格模式

	- 类和模块的内部默认使用严格模式，所所以不需要使用 use strict 指定运行模式。

- constructor 方法

	- 描述

		- constructor 方法是类的默认方法，通过 new 命令生成对象实例时自动调用该方法。一个类必须有 constructor 方法，如果没有显示定义，一个空的 constructor 方法会被默认添加。
		- constructor 方法默认返回实例对象（即 this），不过完全可以指定返回另一个对象。

- 类的实例对象

	- 与ES5一样，实例的属性除非显示定义在其本身（即 this 对象）上，否则都是定义在原型（即 Class）上，这也意味着可以通过实例的 __proto__ 属性为"类" 添加方法。

		- 注意：__proto__ 并不是语言本身的特性，而是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。

	- 与ES5一样，类的所有实例共享一个原型对象。

- 不存在变量提升

	- 类不存在变量提升(hoist)，这一点与 ES5 完全不同。
	- 这种规定的原因与类的继承有关，必须保证子类在父类之后定义。若存在 class 的提升，可能导致子类继承父类的时候，父类还没有定义。

- 私有方法和属性

	- 私有方法

		- 描述：私有方法是常见需求，但 ES6 不提供，只能通过变通方法来模拟实现。
		- 做法

			- 一，在命名上加以区别，以"_" 下划线表示这是一个只限于内部使用的私有方法，但是这种命名是不保险的，在类的外部依然可以调用这个方法。（this._foo() {}）
			- 二，索性将私有方法移除模块，因为模块内部的所有方法都是对外可见的。
			- 三，利用 Symbol 值的唯一性将私有方法的名字命名为一个 Symbol 值。

	- 私有属性

		- 描述：与私有方法一样，ES6 不支持私有属性。
		- 提案

			- 方法是在属性名前，用#来表示（#x），私有属性与实例的属性是可以同名的。
			- 之所以要引入一个新的前缀 # 来表示私有属性，而没有采用 private 关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一可靠的方法。

- 静态方法和属性/实例属性

	- 静态方法

		- 类相当于实例的原型，所有在类中定义的方法都会被实例继承。如果在一个方法前加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类调用，称为 "静态方法" 。
		- 父类的静态方法可以被子类继承，静态方法也可从 super 对象上调用。

	- 静态属性和实例属性

		- 描述：静态属性值的是 Class 本身的属性名，即 Class.propnam，而不是定义在实例对象(this) 上的属性。
		- 静态属性

			- 类名.属性名；Foo.prop = 1;  Foo.prop;// 1
			- 上面的写法可以读/写 Foo 类的静态属性 prop
			- 注：目前只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。

		- 提案

			- Class 实例属性可以用等式写入类的定义中（不用放在 构造方法 constructor{} 中。对于那些在 constructor 里面已经定义的实例属性，新写法允许直接列出；
			- Class 静态属性只要在实例属性的写法前面加上 static关键字就可以了。

- this 的指向

	- 类的方法内部如果含有 this, 它将默认指向类的实例，但是一旦脱离类单独使用该方法，很可能会报错。
	- 解决方法

		- 一，在构造方法中绑定 this，这样就不会出现 this 指向发生变化而引发的错误

			- constructor() { this.foo = this.foo.bind(this); }

		- 二，箭头函数
		- 三，使用 Proxy，在获取方法的时候自动绑定 this

- getter 和 setter

	- 与 ES5 一样，在"类"的内部可以使用 get 和 set 关键字对某个属性设置存值函数和取值函数，拦截该属性的存取行为。
	- 存值函数和取值函数是设置在属性的 Descriptor 对象上的

- Generator 方法

	- 如果某个方法之前加上星号(*)，就表示该方法是一个 Generator 函数

- new.target 属性

	- 描述：new 是从构造函数生成实例的命令。ES6 为 new 命令引入了 new.target 属性，（在构造函数中）返回 new 命令所作用的构造函数。如果构造函数不是通过 new 命令调用的，那么 new.target 会返回 undefined，因此这个属性可以用于确定构造函数怎么调用的。
	- Class 内部调用 new.target，返回当前 Class
	- 注

		- 子类继承父类时 new.target 会返回子类。利用这个特点，可以写出不能独立使用而必须继承后才能使用的类。
		- 在函数外部，使用 new.target 会报错。

- 注

	- 定义"类"的方法时，前面不需要加上 function 这个保留字，直接把函数的定义放进去就可以了。另外，方法直接不需要逗号分隔，加了会报错。
	- 类必须使用 new 来调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。
	- 本质上，由于 ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括 name 属性（总是返回紧跟在 class 关键字后的类名）。

### Class 的继承

- 描述

	- Class 可以通过 extends 关键字实现继承，这比 ES5 通过修改原型链实现继承更加清晰和方便。

	- 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。

	- 注

		- 如果子类没有定义 constructor 方法，那么这个方法会被默认添加。
		- 在子类的构造函数中，置于调用 super 之后才可以使用 this 关键字，否则会报错。这是因为子类实例的构建是基于对父类实例的架构，只有super 方法才能返回实例。

- 继承的实质

	- ES5 的继承实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面(Parent.apply(this)。
	- ES6 的继承机制完全不同，实质是先创造父类的实例对象 this 所以必须先调用 super 方法），然后再用子类的构造函数修改 this。

- Object.getPrototypeOf()

	- 该方法可以用来从子类上获取父类
	- 可以使用这个方法判断一个类是否继承了另一个类

- super 关键字

	- 使用方式

		- 第一种情况，super 作为函数调用时代表父类的构造函数。

			- ES6 要求，子类的构造函数必须执行一次 super 函数。作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。
			- super 代表了父类A 的构造函数，但是返回的是子类 B 的实例,即 super 内部的 this 指的是 B，因此 super() 在这里相当于 A.prototype.constructor.call(this)。(可用 new.target 检验)。

		- 第二种情况，super 作为对象时在普通方法中指向父类的原型对象；在静态方法中指向父类。

			- 由于 super 指向父类的原型对象，所以定义在父类实例上的方法或属性是无法通过 super 调用的。
			- ES6 规定，通过 super 调用父类的方法时，super 会绑定子类的 this。(实际执行的是 super.xxx.call(this))。
			- 由于绑定子类的 this，因此如果通过 super 对某个属性赋值 super.x = xxx，这时 super 就是 this ，赋值的属性会变成子类实例的属性。  但是当读取 super.x 时，相当于读取的是 父类.prototype.x
			- 如果 super 作为对象用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象。

	- 注

		- 使用用 super 时，必须显示指定是作为函数还是作为对象使用，否则报错。
		- 由于对象总是继承其他对象的，所以可以在任意一个对象中使用 super 关键字

- 类的 prototype 属性和 __proto__ 属性

	- 描述

		- 在大多数浏览器的 ES5 实现之中，每一个对象都有 __proto__ 属性，指向对应的构造函数的 prototype 属性。
		- Class 作为构造函数的语法糖，同时有 prototype 属性和 __proto__属性，因此同时存在两条继承链。

			- 子类的 __proto__ 属性表示构造函数的继，总是指向父类。
			- 子类 prototype 属性的 __prototype__ 表示方法的继承，总是指向父类的 prototype 属性。
			- 原因：因为类的继承是按照左边的模式实现的。

			- 补充：Object.setPrototypeOf 方法的实现

		- 两条继承链可以这样理解: 作为一个对象，子类(B)的原型（__proto__属性）是父类(A)；作为一个构造函数，子类(B)的原型（prototype属性） 是父类的实例。

- extends 的继承目标

	- 描述

		- extends 关键字后面可以跟多种类型的值

	- 三种特殊情况

		- 子类继承 Object 类

			- 这种情况下，A 其实就是构造函数 Object 的复制，A 的实例就是 Object 的实例。

		- 不存在任何继承

			- 这种情况下，A作为一个基类(即不存在任何继承)就是一个普通函数，所以直接继承 Function.prortotype。但是，A 调用后返回一个空对象（即 Object 实例），所以 A.prototype.__proto__指向构造函数(Object)的 prototype 属性。

		- 子类继承 null

			- 这种情况与第二种情况非常。A 也是一个普通函数，所以直接继承 Function.prototype。但是，A 调用后返回的对象不继承任何方法，所以它的 __proto__ 指向 Function.prototype，即实质上执行了下面的代码。
- 实例的 __proto__ 属性

	- 子类型的__proto__的属性的__proto__属性指向父类实例的__proto__属性。也就是说，子类的原型的原型是父类的原型。
	- 因此，可以通过子类实例的__proto__.__proto__属性修改父类实例的行为。

- 原生构造函数的继承

	- ECMAScript 的原生构造函数

		- Boolean、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()
		- 以前，这些原生构造函数是无法继承的，是因为子类无法获得原生构造函数的内部属性，例如通过 Array.apply() 或者分配给原始对象(xxx.prototype = Object.create(Array.prototype);)。原生构造函数会忽略 apply(call) 方法传入的 this，也就是说，原生构造函数的 this 无法绑定，导致拿不到内部属性。
		- ES5 是先新建子类的实例对象 this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array 构造函数有一个内部属性 [[DefineOwnProperty]]，用来定义新属性时，更新 length 属性，这个内部属性便无法在子类获取，导致子类的 length 属性不正常。

	- ES6

		- ES6 允许继承原生构造函数定义子类，因为ES6 先新建父类的实例对象 this，然后再用子类的构造函数修饰 this，使得父类的所有行为都可以继承。ES6 可以自定义原生数据结构的子类，这是 ES5 无法做到的。
		- 另外 extends 关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的继承上定义自己的数据结构。

- Mixin 模式的实现

### 类的修饰器

- 描述：修饰器（Decorator）是一个函数，用来修改类的行为。ES2017引入

## Module

### 语法

- 描述

	- 与其他模块方案比较

		- ES6 之前，最主要的模块加载方案有，CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。
		- ES6 在语言规格的层面上实现了模块功能，而且实现的相当简单，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。
		- ES6模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。
		- CommonJS 和 AMD 模块都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。这种加载称为“运行时加载”，因为只有运行时才能得到这个模块的输出，导致完全没办法在编译时进行“静态优化”。

	- ES6模块的实质

		- 加载方式称为“编译时加载”或者静态加载，即ES6 可以在编译时就完成模块加载，效率比 CommonJS 模块的加载方式高，同时这也导致了 ES6模块本身无法被引用，因为它不是对象。

	- 优势

		- 因为是编译时加载，使得静态分析成为可能。有了它就能进一步拓展 JS 的语法，比如引入宏（macro）和类型检验（type system）这些只能依靠静态分析实现的功能。
		- 不再需要 UMD 模块格式，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库其实已经做到了这一点。
		- 将来浏览器的新 API 已经可以用模块格式提供，不再需要做成全局变量或 navigator 对象的属性。
		- 不再需要对象作为命名空间（比如 Math 对象），未来这些功能可以通过模块来提供。

- 严格模式

	- 描述

		- ES6 的模块自动采用严格模式，不管有没有在模块头部加上 "use strict"

	- 限制

		- - 变量必须声明后再使用。
		- - 函数的参数不能有同名属性，否则报错。
		- - 不能使用 with 语句。
		- - 不能对只读属性赋值，否则报错。
		- - 不能使用前缀 0 表示八进制数，否则报错。
		- - 不能删除不可删除的属性，否则会报错。
		- - 不能删除变量， delete prop，会报错，只能删除属性， delete global[prop]。
		- eval 不会在它的外层作用域引入变量。
		- - eval 和 arguments 不能被重新赋值
		- - 不能使用 arguments.callee，arguments.caller。
		- 禁止 this 指向全局对象。
		- 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈。
		- 增加了保留字（比如 protected、static 和 interface。

- export 命令

	- 描述

		- 模块功能主要又两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。
		- 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。

	- 写法

		- 输出变量

			- export var xxx = xxx;
			- var a = 1; var b = 2; var c = 3; export { a,b,c };

		- 输出函数或类

			- export function fn() {};
			- export class xxx {}

		- 用 as 重命名输出

			- function v1() {}; function v2() {}; export { v1 as streamV1, v2 as streamV2, v2 as streamLasestVersion }
			- 用 as  关键字重命名，重命名后，v2 可以用不同的名字输出两次

	- 注

		- export 命令规定是对外的接口，必须与模块内部的变量建立一一对应关系。

			- 报错

				- export 1;
				- var m = 1; export m;

		- export 语句输出的接口与其对应的值是动态绑定关系。即通过该接口可以去到模块内部实时的值。

			- CommonJS 模块输出的是值的缓存，不存在动态更新。

		- export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错（import 也是如此）。这是因为处于条件代码块中，就没法做静态优化了，违背了 ES6 模块的设计初衷。

- import 命令

	- 描述

		- 通过 import 命令加载模块，import 命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号中的变量必须与被导入模块对外接口的名称相同。
		- import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件告诉 JavaScript 引擎该模块的位置。

	- 写法

		- 导入

			- import { a,b,c } from './xxx'

		- as 重命名

			- import { a as firstname }

	- 注

		- import 命令具有提升效果，会提升到整个模块的头部并首先执行。这种行为的本质是，import 命令是编译阶段执行的，在代码运行之前。
		- 由于 import 是静态执行，所以不能使用表达式和变量，只有在运行时才能得到结果的语法结构。
		- 如果多次重复执行同一句 import 语句，那么只会执行一次。因为加载的两个语句对应的是同个模块实，说明 import 语句是 Singleton 模式(单例模式)。

- 模块的整体加载

	- 描述

		- 除了指定加载某个输出值，还可以使用整体加载（即星号 *）来指定一个对象，所有输出值都加载在这个对象上。

	- 注

		- 模块整体加载的对象应该是可以静态分析的，所以不允许运行时改变。
		- export * 会忽略模块的 default 方法。

- export defaul 命令

	- 描述

		- 使用该命令为模块指定默认输出。
		- 一个模块只能有一个默认输出。
		- 本质是将该命令后面的值赋给 default 变量以后再默认，所以可以直接将一个值写在 export default 之后。

	- 写法

		- export default function fn() {}
		- 加载该模块时，import 命令无需知道原模块输出的名称，可以指定任意名字。无需大括号。

			- import xxx from './xxx'

	- 注

		- 可以在一条 import 语句中同时输入默认方法和其他接口。

			- import xx, { xx,x,xxx } from './xx'

- export 与 import 的复合写法

	- 描述

		- 如果在一个模块之中先输入后输出同一个模块，import 语句可以与 export 语句写在一起
		- 一样可以用 as 重命名

	- 写法

		- export { foo,bar } from ' ./xx '
		- 等价于 import { foo,bar  } from './xx';                
 export {foo ,bar };

- 模块的继承

	- 使用 export * from ‘xxx’; 来输入输出 xx 模块的所有属性和方法。

- 跨模块常量

	- 描述

		- 设置跨模块的常量（即跨多个文件），或者说是一个值要被多个模块共享。

	- 写法

		- 模块A： export const A = 1; 
                    export const B = 2; 
		- 模块B: import * as xxx from './A'; 
               console.log(xxx.A);  // 1
               console.log(xxx.B);  // 2
		- 模块C: import {A,B} from './A';                
               console.log(A);  // 1
               console.log(B);  // 2

- import()

	- 描述

		- import 命令会被 JS 引擎静态分析，先于模块内的其他模块执行（称为“连接” 更合适），不能在代码块中（比如，在 if 代码块中，或在函数之中）。
		- 这样的设计虽然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载不可能实现，所以 import 无法取代 Node 的 require 的动态加载功能。
		- 所以有个提案，引入 import() 函数，完成动态加载。
		- import() 函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，运行到这一句变回加载指定的模块。另外，import() 函数与所加载的模块没有静态连接关系，与 import 语句不同。
		- import() 类似于 Node 的 require 方法，区别主要是，前者是一部加载，后者是同步加载。

	- 返回值

		- import() 返回一个 Promise 对象

			- import('./xxxxxxx.js').then( module => { //... }). catch( err => { //... } );

	- 注

		- import() 加载模块成功后，这个模块会作为一个对象当做 then 方法的参数，所以可以使用对象解构赋值的语法，获取输出接口。

			- import('./xxxxxxx.js').then(( { export1, export2} ) => { //... });

		- 如果模块有 default 输出接口，可以用参数直接获得。也可以用具名输入的形式。

			- import('./xxxxxxx.js').then( module => { //... });
			- import('./xxxxxxx.js').then( {default: theDefault } => { //... });

		- 同时加载多个模块使用 Promise.all
		- import() 也可以使用在 asycn 函数中

	- 使用场合

		- 按需加载

			- import() 可以在需要的时候再加载某个模块

		- 条件加载

			- import() 可以放在 if 代码块中，根据不同的情况加载不同的模块。

		- 动态的模块路径

			- import() 运行模块路径动态生成

				- 例如：import( f() ).then(...);

### 加载实现

- CommonJS 模块的加载原理

	- 描述

		- CommonJS 的一个模块就是一个脚本文件。require 命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象。

			- {  id:'.........' ,exports:{ ... },  loaded: true, ...      }

		- 左边的就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loader 属性是一个布尔值，表示该模块的脚本是否执行完毕，其他属性省略。
		- 以后需要用到这个模块时就会到 exports 属性上取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。
		- 也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行异常，以后再加载时就返回第一次运行的结果，除非手动清除系统缓存。

- ES6 模块与 CommonJS 模块的差异

	- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

		- CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行结束时才会生产。
		-  ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

	- CommonJS 模块输出的是一个值的复制，ES6 模块输出的是值的引用。

		- CommonJS

			- CommonJS 模块输出的是值的复制，也就是说一旦输出一个值，模块内部的变化就影响不到这个值。
			- 输出缓存机制

		- ES6 模块

			- ES6 模块的运行机制是 JS 引擎对脚本静态分析的时候，遇到模块加载命令 import 就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用到被加载的模块中取值。
			- ES6 模块是动态引用，不会缓存运行的结果，而是动态地去被加载的模块取值，模块里面的变量绑定其所在的模块。
			- 由于 ES6 输入的模块变量只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。
			- export 通过接口输出的是同一个值。不同的脚本加载这个接口得到的都是同样的实例。

- 浏览器加载

	- 传统方法

		- 描述

			- 在 HTML 网页中，浏览器通过 <script> 标签加载 JavaScript 脚本。
			- 默认情况下，浏览器同步加载 JavaScript 脚本，即渲染引擎遇到 <script> 标签就会停下来，等到脚本执行完毕再继续向下渲染。如果是外部脚本，还必须加入脚本下载时间。
			- 若脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应，这明显是很不好的体验，所以浏览器允许脚本异步加载。

		- 写法

			- 内嵌脚本：<script type="application/javascript"> </script>
			- 外部脚本：<script type="application/javascript" src="xxx/xx/xx.js"></script> 
			- 注：由于浏览器脚本默认的语言是 JavaScript 因此 type="application/javascript" 可以省略。

		- 异步加载语法

			- 描述

				- <script> 标签打开 defer 或 async 属性，脚本就会异步加载。渲染引擎遇到这一行命令就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

			- 写法

				- defer：<script src="xx.js" defer></script>
				- async：<script src="xx.js" async></script>

			- 区别

				- defer 要等到整个页面正常渲染结束才会执行——"渲染完再执行"
				- async 一旦下载完成，渲染引擎就会中断渲染，执行整个脚本以后再继续渲染——“下载完就执行”
				- 若有多个 defer 脚本，会按照它们在页面中出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。

	- ES6 模块

		- 描述

			- 浏览器加载 ES6 模块时也使用 <script> 标签，但是要加入 type="module" 属性。
			- 对于带有 type=“module” 的 <script> 标签，浏览器都是异步加载的，不会造成浏览器堵塞，即等到整个页面渲染完再执行模块脚本，等同于打开了 <script> 标签的 defer 属性
			- <script> 标签的 async 属性也可以手动打开，这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。

		- 写法

			- <script type="module" src="xx.js"></script>
			- 等价于：<script type="module" src="xx.js" defer></script>
			- async 方式异步：<script type="module" src="xx.js" async></script>

		- 注

			- ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。
			- 对于外部的模块脚本

				- 代码是在模块作用域之中进行的，而不是在全局作用域中运行、模块内部的顶层变量是外部不可见的。
				- 模块脚本自动采用严格模式，无论有没有声明 use strict。
				- 模块之中可以使用 import 命令加载其他模块( .js 后缀不可省略，需要提供绝对 URL 或相对 URL)，也可以使用 export 命令输出对外接口。
				- 在模块之中，顶层的 this 关键字返回 undefined，而不是指向 window。也就是说，在模块顶层使用 this 关键字是无意义的。
				- 同一个模块如果加载多次，将只执行一次。

- Node 加载

	- 描述

		- Node 采用 CommonJS 模块格式，模块的输出都定义在 module.exports 属性上面。
		- Node 有自己的 CommonJS 模块格式，与 ES6 模块格式是不兼容的。目前的解决方案是将两者分开，ES6 模块和 CommonJS 采用各自的加载方案。
		- 在静态分析阶段，一个模板脚本只要有一行 import 或 export 语句，Node 就会认为该脚本为 ES6 模块，否则就为 CommonJS 模块。如果不输出任何接口，但是希望被 Node 认为是 ES6 模块，可以在脚本中加上：export {};
		- 如果加载时不指定绝对路径，Node 加载 ES6 模块会与 require() 的规则一致。

			- import './foo';

				- ./foo.js
				- ./foo/package.json
				- ./foo/index.js

		- ES6 模块之中，顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。这是两者的一个重大差异。

	- import 命令加载 CommonJS 模块

		- 描述

			- Node 会自动将 module.exports 属性当作模块的默认输出，即等同于 export default。
			- 如果采用整体输入的写法 ( import * as xxx from  xxx), default 会取代 module.exports 作为输入的接口。 要通过 xxx.default 这种写法才能获取到 module.exports。
			- CommonJS 模块的输出缓存机制在 ES6 加载方式下依然有效

		- 注

			- 由于 ES6 模块是编译时确定输出接口，CommonJS 模块是运行时确定输出接口，所以采用 import 命令加载 CommonJS 模块时，不允许采用这种写法：import { readfile } from 'fs';
			- 因为 fs 是 CommonJS 格式，只有运行时才能确定 readfile 接口，而 import 命令要求编译时就确定这个接口，解决方法就是改为整体输入。

	- require 命令加载 ES6 模块

		- 描述

			- 采用 require 命令加载 ES6 模块时，ES6 模块的所有输出接口都会成为输入对象的属性。
			- default 接口会变成 xxx.default 属性
			- 而且由于存在缓存机制，模块内部变量的变化没有在模块外部反映出来。

- 循环加载

	- 描述

		- "循环加载"(circular dependcy) 指的是，a 脚本的执行依赖 b 脚本，而 b 脚本的执行又依赖 a 脚本。

			- a.js:  var b = require('b');
			- b.js: var a = require('a');

		- 通常，"循环加载"表示存在强耦合，如果处理不好，还可能导致地柜加载，是的程序无法执行，因此应该避免出现这种现象。

	- CommonJS 模块的循环加载

		- 描述

			- CommonJS 模块的重要特性就是加载时执行，即脚本代码在 require 的时候就会全部执行。
			- 一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。

		- 注

			- 由于 CommonJS 模块遇到循环加载时返回的是当前已经执行的部分的值，而不是代码全部执行之后的值，两者可能会有差异。所以，输入变量的时候必须非常小心。

	- ES6 模块的循环加载

		- 描述

			- ES6 模块的特性是动态引用
			- 如果使用 import 从一个模块中加载变量（即 import foo from 'foo'）, 那么，变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者保证在真正取值的时候能够取到值。

		- 注

			- 已经开始执行的模块，不会重复执行。
			- 由于 ES6 加载的变量都是动态引用其所在模块的。只要引用存在，代码就能执行。

### ES6 模块的转码

- Babel
- ES6 module transpiler

	- square 公司开源的转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块。

- SystemJS

	- 是一个垫片库（polyfill），可以在浏览器加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式，在后台调用的是 Google 的 Traceur 转码器。

*XMind: ZEN - Trial Version*