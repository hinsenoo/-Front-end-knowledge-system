# 介绍一下浏览器缓存

## 概念

**浏览器缓存** 是浏览器将用户请求过的静态资源（HTML、CSS、JS），存储到本地中，当浏览器再次访问时，就可以直接从本地加载了，不需要再去服务端请求了。

缓存的优点：

- 减少了冗余的数据传输，节省流量
- 减少服务器的负担，提升网站性能
- 加快客户端加载网页的速度

但也不是说缓存没有缺点，如果处理不当，可能会导致服务端代码更新了，但是用户却还是老页面。所以前端们要针对项目中各个资源的实际情况，做出合理的缓存策略。

## 缓存流程

所有的性能优化中，缓存是最重要也是最直接有效的。

缓存分为强缓存和协商缓存，流程如下

![img](assets/17085a970e66cf41)

## 缓存规则

浏览器中的缓存作用分为两种情况，一种是需要发送 `HTTP` 请求，一种是不需要发送。

首先是检查强缓存，这个阶段不需要发送 HTTP 请求。

### 强缓存

如何来检查呢？通过相应的字段来进行：

在 `HTTP/1.0` 和 `HTTP/1.1` 当中，这个字段是不一样的。在早期，也就是 `HTTP/1.0` 时期，使用的是 **Expires**，而 `HTTP/1.1` 中使用的是 **Cache-Control**。

#### Expires

`Expires` 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如：

```js
Expires: Wed, 22 Nov 2019 08:41:00 GMT
```

表示资源在 `2019年11月22号8点41分` 过期，过期了就得像服务端发请求。

这个方式看起来没什么问题，但其实潜藏了一个坑，就是 **服务器时间和浏览器的时间可能并不一致**，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的 `HTTP1.1` 版本中被抛弃了。

#### Cache-Control

在 HTTP1.1 中，采用了一个非常关键的字段：`Cache-Control`。这个字段也是存在于服务器返回的响应头中。

它和 `Expires` 本质的不同在于它并没有采用 **具体的过期时间点** 这个方式，而是采用过期时长来控制缓存，对应的字段是 `max-age`。比如：

```js
Cache-Control: max-age=3600
```

代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

它其实可以组合非常多的指令，完成更多场景的缓存判断，将一些关键的属性列举如下：

- **public**：浏览器和代理服务器都可以缓存。
- **private**：这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
- **no-cache**：跳过当前的强缓存，发送 HTTP 请求，即直接进入 **协商缓存阶段**。（重要）
- **max-age**：过期时间（重要）
- **no-store**：不强缓存，也不协商缓存。

注：规则可以同时多个。当 **Expires** 和 **Cache-Control** 同时存在的时候，**Cache-Control** 会优先考虑。

当然，当资源缓存时间超时了，也就是 **强缓存** 失效了，这样就进入到第二种规则——**协商缓存**了。

### 协商缓存

强缓存失效之后，浏览器在请求头中携带相应的 **缓存 tag** 来向服务器发请求，由服务器根据这个 tag，来决定是否使用缓存，这就是协商缓存。

具体来说，这样的缓存 tag 分为两种：`Last-Modified` 和 `ETag`。这两者各有优劣，并不存在谁对谁有 **绝对的优势**，跟上面强缓存的两个 tag 不一样。

#### Last-Modified

即**最后修改时间**，在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，如果再次请求，会在请求头中携带 `If-Modified-Since` 字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的 `If-Modified-Since` 的字段后，其实会和这个服务器中 **该资源的最后修改时间** 对比：

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 `304`，告诉浏览器直接使用缓存。

#### ETag

`ETag` 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会改变。服务器是通过响应头把这个值给浏览器。

浏览器接收到 `ETag` 的值，会在下次请求时，将这个值作为 `If-None-Match`（如果不匹配的意思） 这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到 `If-None-Match`后，会跟服务器上该资源的 `ETag` 进行对比：

- 如果两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 `304` 告诉浏览器直接用缓存。

#### 两者对比

1. 在**精确度**上，`ETag` 优于 `Last-Modified`。优于 `ETag` 是按照内容给资源上标识，因此能准确感知资源的变化。而 `Last-Modified` 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况：
   - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
   - `Last-Modified`能够感知的单位是秒，如果文件在一秒内改变了多次，那么这时候的 `Last-Modified` 并没有体现出修改了。
2. 在性能上，`Last-Modified` 优于 `ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `ETag` 需要根据文件的具体内容生成哈希值。

另外，如果两种方式都支持的话，服务器会优先考虑`ETag`。

## 缓存位置

浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：

- Service Worker
  - Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问`DOM`。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如`离线缓存`、`消息推送`和`网络代理`等功能。其中的`离线缓存`就是 **Service Worker Cache**。
- Memory Cache —— 内存缓存
  - 从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
- Disk Cache —— 存储在磁盘中的缓存
  - 从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。
  - 注：比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内容；内存使用率比较高的时候，文件优先进入磁盘。
- Push Cache —— 推送缓存

## 总结

首先通过 `Cache-Control` 或者 `Expires`验证强缓存是否可用

- 如果强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的 `If-Modified-Since`  或者 `If-None-Match` 字段检查资源是否更新
  - 若资源更新，返回资源和 `200` 状态码
  - 否则，返回 `304`，告诉浏览器直接从缓存获取资源