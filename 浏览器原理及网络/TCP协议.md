## 1. TCP 和 UDP 的区别？

首先概况一下基本的区别：
-	**TCP **
  -	面向连接的传输层协议
  -	面向字节流
  -	提供可靠交付
  -	使用全双工通信（TCP 连接建立完后客户端和服务端都能发送和接收数据）

- **UDP **
  - 面向无连接的协议，进行不可靠的传输
  - 面向数据包
  - 没有拥塞控制
  - UDP 数据报首部开销小
  - 支持一对一、一对多、多对多、多对一的数据传输

具体来分析，和 UDP 相比，TCP 有三大核心特性：

1. **面向连接**。所谓的连接，指的是客户端和服务端的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有响应建立连接的过程。
2. **可靠性**。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在：一个是有状态，另一个是可控制。（相应的 **UDP 就是无状态的、不可控的**。
   - TCP 会精确记录哪些数据发送了，以及数据是否被对方接收，而且保证数据包按序到达，不允许半点差错，这是**有状态**。
   - 当意识到丢包或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发，这是**可控制**。
3. **面向字节流**。UDP 的数据传输是基于数据报的，这是因为仅仅是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成字节流



## 2. TCP 数据报

![img](assets/172e5156ea70ba32)

### 源端口、目标端口

如何唯一标识一个连接？ 答案是 TCP 连接的`四元组`—— 源 IP、源端口、目标 IP 和目标端口。

那 TCP 报文怎么没有源 IP 和 目标 IP 呢？这是因为在网络层（IP 层）就已经处理了 IP。TCP 只需要记录两者的端口即可。

### 序号（Sequence number）

在一个 TCP 连接中传送的字节流中的每个字节都按顺序编号。字节流的起始序号必须在连接建立时设置。

TCP 数据报首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。

序号在 TCP 通信的过程中有两个作用：

1. 在 SYN 报文中交换彼此的初始序列号。
2. 保证数据包按正确的顺序组装。

### 确认号（ACK，Acknowledgment number)

即期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则表明：到序列号 N-1 为止的数据都已正确收到。

### 数据偏移（头部长度）

它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。

### 标记位

常见的标记位有 `SYN`,`ACK`,`FIN`,`RST`,`PSH`。

- `SYN`：在连接建立时用来同步序列号，当 `SYN = 1` 而 `ACK = 0`时，表明这是一个连接请求报文段。
- `确认ACK`：仅当 `ACK=1` 时确认号字段才有效。当 `ACK=0` 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- `FIN`：即 Finish，表示发送方准备断开连接。
- `复位RST`：即 Reset，当 `RST=1`时，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立运输连接
- `推送PSH`：即 PUSH，告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。

### **窗口**

窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着 窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）。

### 校验和

校验和字段检验的范围包括首部和数据这两部分，在计算校验和时，要在 TCP 报文段的前面加上 12 字节的伪首部（同 UDP），

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。

### ISN （Initial Sequence Number，初始序列号）

三次握手的过程当中，双方会用过`SYN`报文来交换彼此的 `ISN`。

ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。那为什么要这么做？

如果 ISN 被攻击者预测到，要知道源 IP 和源端口号都是很容易伪造的，当攻击者猜测 ISN 之后，直接伪造一个 RST 后，就可以强制连接关闭的，这是非常危险的。

而动态增长的 ISN 大大提高了猜测 ISN 的难度。

### 可选项

可选项的格式如下:

![img](assets/170723f4facdfb22)

常用的可选项有以下几个:

- TimeStamp: TCP 时间戳，后面详细介绍。
- MSS: 指的是 TCP 允许的从对方接收的最大报文段。
- SACK: 选择确认选项。
- Window Scale： 窗口缩放选项。

## 3. TCP 三次握手的过程

作用：为了确认双方的接收与发送能力是否正常

> **为什么一定要三次才可以，而两次不可以**
>
> - 第一次握手：客户端发包，服务端收到了。服务端得到结论：客户端的发送能力、服务端的接收能力正常。
>
> - 第二次握手：服务端发包，客户端收到了。客户端得出结论：服务端的接收、发送能力正常，客户端的接收、发送能力正常。但是此时的服务器并不能确认客户端的接收能力是否正常。
> - 第三次握手：客户端发包，服务端收到了。服务器得出结论：客户端的接收、发送能力正常，服务端自己的发送、接收能力也正常。
>
> 因此，需要三次握手才能确认双方的接收与发送能力是否正常。当然更多次的握手都可以，但是三次就足够了。

### 握手过程

![img](assets/16a4e89718f94f91)

（注：标志位为 SYN 和 ACK 表示 "确认 seq 序号有效"，确认号为 ack = x +1）

从最开始双方都处于 `CLOSED` 状态，客户端主动打开连接，服务器**被动打开**进入 `LISTEN` 状态，然后：

- 第一次握手：客户端主动发起连接，给服务器发送一个 **SYN** 报文，并指明客户端的初始化序号 **ISN** 此时客户端状态为 `SYN-SENT` 状态。
- 第二次握手：服务器收到客户端的 **SYN** 报文后，会以自己的 **SYN** 报文作为应答，并且也指定了自己的初始化序号，同时会把客户端的 **ISN + 1** 作为 **ACK** 的值，表示自己已经收到客户端的 **SYN**，此时服务器处于 `SYN_RCVD` 状态。
- 第三次握手：客户端收到服务器的 **SYN** 报文后，会发送一个 **ACK** 报文，也是一样把服务器的 **ISN + 1** 作为 **ACK** 的值，表示已经收到了服务器的 **SYN** 报文，此时客户端状态为 `ESTABLISHED` 状态。
- 服务器收到 **ACK** 报文后，也处于 `ESTABLISHED`状态，此时，双方已建立起了连接。

### 三次握手的作用：

1. 确认双方的接收能力、发送能力是否正常。
2. 指定自己的初始化序号，为后面的可靠传送做准备。
3. 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的研制以及加密密钥的生成。

#### 1. ISN 是固定的吗？

三次握手的一个重要功能是客户端和服务端交换 ISN，以便让对方知道接下来接收数据的时候如何按序列号组装数据。

如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

#### 2. 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立其连接，服务器会把此种状态下的请求连接放在一个队列中，这种队列称之为**半连接队列**。

**全连接队列**就是已经完成三次握手，建立起的连接就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

> 补充：SYN-ACK 重传次数：服务器发完 SYN-ACK 包，如果为收到客户端确认包，服务器将进行首次重传，等待一段时间仍未收到客户端确认包，将进行二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除，注意：每次重传等待的时间不一定相同，一般会是指数增长。

#### 3. 三次握手过程中可以携带数据么？

第三次握手的时候，可以携带。前两次握手不能携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的**时间**和**内存空间**去处理这些数据，增大了服务器被攻击的风险。

第三次握手的时候，客户端已经处于`ESTABLISHED`状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

## 4. TCP 四次挥手的过程

![img](assets/16a4e8e413941b94)

刚开始双方处于 `ESTABLISHED` 状态，假如是客户端先发起关闭请求，则：

- 第一次挥手：客户端发送一个 **FIN** 报文，报文中会指定一个序号。此时客户端处于 `FIN_WAIT1`状态。
- 第二次挥手：服务端收到 **FIN** 之后，会发送 **ACK** 报文，且把客户端的序号值 + 1 作为 **ACK** 报文的序列号值，表明已经收到客户端的报文，此时服务端处于 `CLOES_WAIT`状态，客户端接收到了服务端的确认后变成了 `FIN_WAIT2` 状态。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送给 **FIN** 报文，且指定一个序号。此时服务端处于 `LAST-ACK` 的状态。
- 第四次挥手：客户端收到 **FIN** 之后，一样发送一个 **ACK** 报文作为应答，且把服务端的序号值 + 1 作为自己 **ACK** 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态，需要等待 **2MSL** 后以确保服务端收到自己的 **ACK** 报文后才会进入 `CLOSED` 状态。

注意：客户端需要具体等待 2 个 `MSL` （Maximum Segment Lifetime, 报文最大生存时间），在这段时间内如果客户端没有收到服务端的重发请求，那么表示 **ACK** 成功到达，挥手结束，否则客户端重发 **ACK**。

### 等待 2MSL 的意义

如果不等待会怎样？

如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。

那照这样说一个 MSL 不就够了吗？为什么要等待 2 MSL？

- 一个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能够到达对端
- 一个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达

这就是等待 2MSL 的意义



### 为什么是四次挥手而不是三次？

因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。因此先发一个`ACK`表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。

如果是三次挥手会有什么问题？

等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

