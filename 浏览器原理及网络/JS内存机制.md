# JS 内存机制

## JavaScript 中的数据是如何存储在内存中的

### JavaScript 是什么类型的语言？

- 在使用之前就需要**确定其变量数据类型**的称为**静态语言**，在运行过程中需要检查数据类型的语言称为**动态语言**。（JavaScript 就是动态语言）
- **支持隐式类型转换**的语言称为**弱类型语言**，不支持隐式类型转换的语言称为**强类型语言**

![1634046590834](assets/1634046590834.png)

### JavaScript 的数据类型

JavaScript 是一种弱类型的、动态的语言。特点：

- **弱类型**：意味着不需要告诉 JS 引擎某个变量是什么数据类型，JS 引擎在运行代码的时候会自行计算出来。
- **动态**：意味着可以使用同一个变量保存不同类型的数据。

在 JavaScript 中，可以使用 `typeof` 运算符查看变量的数据类型。如下：

```js
var bar 
console.log(typeof bar) //undefined 
bar = 12 
console.log(typeof bar) //number 
bar = "hinsenoo" 
console.log(typeof bar) //string 
bar = true 
console.log(typeof bar) //boolean 
bar = null 
console.log(typeof bar) //object 
bar = {name: "hinsenoo"} 
console.log(typeof bar) //object
```

JavaScript 中的数据类型一共有 8 种， 它们分别是：

| 类型          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| **Boolean**   | 只有 `true` 和 `false` 两个值。                              |
| **Null**      | 只有一个值 `null`。                                          |
| **Undefined** | 一个没有被赋值的变量会有个默认值 `undefined`，变量提升时的默认值也是 `undefined`。 |
| **Number**    | 根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE754 标准的双精度 64 位二进制格式的值，-(263 - 1) 到 263 -1 。 |
| **BigInt**    | JavaScript 中的一个新的数字类型，可以用任意精度表示整数。使用 `BigInt`，即使超出 `Number` 的安全整数范围限制，也可以安全地存储和操作。 |
| **String**    | 用与表示文本数据。不同于类 C 语言，JavaScript 的字符串是不可更改的。 |
| **Symbol**    | 符号类型是唯一的并且是不可修改的，通常用来作为 `Object` 的 `key`。 |
| **Object**    | 在 JavaScript 里，对象可以被看作是一组属性的集合。           |

注意点：

1. 使用 `typeof` 检测 `Null` 类型时，返回的是 `Object`。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老代码。（解释：在 JS 最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `Object`。

2. `Object` 类型比较特殊，它是由上述七种类型组成的一个包含了 `key-value` 对的数据类型。如下所示：

   ```js
   let myObj = {
   	name: 'hinsenoo',
       update: function() {}
   }
   ```

   其中的 `value` 可以是任何类型，包括函数，这也就意味着你可以通过 `Object` 来存储函数，`Object` 中的函数又称为方法。

3. 把前面 7 种数据类型称为 **原始类型**，把最后一个对象类型称为 **引用类型**，之所以把它们区分为不同的类型，是因为它们在内存存放的位置不一样。

### 内存空间

下图是 JavaScript 的内容模型：

![1644670567446](assets/1644670567446.png)

从图中可以看出，在 JavaScript 的执行过程中，主要有三种类型内存空间，分别是 **代码空间**、**栈空间** 和 **堆空间**。（其中代码空间主要是存储可执行代码的）

### 栈空间和堆空间

这里的栈空间就是调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，先看下⾯这段代码： 

```js
function foo() {
	var a = "极客时间"; 
    var b = a; 
    var c = {name:"极客时间"};
    var d = c;
}
foo();
```

当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。下图是，当执行到第三行代码时，其调用栈的状态：

![1644670841920](assets/1644670841920.png)

从图中可以看出，执行到第3行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以也可以认为变量 a 和 b 的值都是存放在栈中的。	

接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候的处理情况就不一样了，JavaScript 引擎并不是直接将对象存放到变量环境中，而是将它分配到堆空间中，分配后该对象会有一个在 “堆” 中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好的内存示意图如下所示：
![1644671387354](assets/1644671387354.png)

从上图可以得知，对象类型是存放在堆空间的，在栈空间只是保存了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。

**原始类型的数据值都是直接保存在 "栈" 中的，引用类型的值是存放在 "堆" 中的**。这样存放的原因是：
因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程可以参考下图：

![1644672451033](assets/1644672451033.png)

所以 **通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

所以 `d=c` 的操作就是把 c 的引用地址复制给 d，可以参考下图：

![1644680365308](assets/1644680365308.png)

### 谈谈闭包

前置知识：作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间，基于这两点探讨一下闭包的内存模型。

例子：

```js
function foo() {
    var myName = "极客时间";
    let test1 = 1;
    const test2 = 2;
    var innerBar = {
        setName: function (newName) {
            myName = newName;
        },
        getName: function () {
            console.log(test1);
            return myName;
        }
    }
    return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName())
```

当执⾏这段代码的时候，你应该有过这样的分析：由于变量 `myName、test1、test2` 都是原始类型数据，所 以在执⾏ foo 函数的时候，它们会被压⼊到调⽤栈中；当 `foo` 函数执⾏结束之后，调⽤栈中 `foo` 函数的执⾏上 下⽂会被销毁，其内部变量 `myName、test1、test2` 也应该⼀同被销毁。 

但是在闭包的⽂章中，介绍了当` foo` 函数的执⾏上下⽂销毁时，由于`foo`函数产⽣了闭包，所以变量 

`myName`和`test1`并没有被销毁，⽽是保存在内存中，那么应该如何解释这个现象呢？ 

要解释这个现象，我们就得站在内存模型的⻆度来分析这段代码的执⾏流程：

1. 当 JavaScript 引擎执行到 `foo` 函数时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 `setName`，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 `foo` 函数的 `myName` 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建了一个 **"closure(foo)"** 的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 `myName` 变量。
3. 接着继续扫描到 `getName` 方法时，发现该函数内部还引用变量 `test1`，于是 JavaScript 引擎又将 `test1` 添加到 **"closure(foo)"** 对象中。这时候堆中的 **"closure(foo)"** 对象中就包含了 `myName、test1` 两个变量。
4. 由于 `test2` 并没有被内部函数引用，所以 `test2` 依然保存在调用栈中。

通过上面的分析，可以画出执行到 `foo` 函数中 "return innerBar" 语句时的调用栈状态，如下图所示：

![1644681736990](assets/1644681736990.png)

从上图你可以清晰地看出，当执⾏到foo函数时，闭包就产⽣了；当`foo`函数执⾏结束之后，返回的 

`getName`和`setName`⽅法都引⽤**“clourse(foo)”**对象，所以即使`foo`函数退出了，**“clourse(foo)”**依然被 

其内部的`getName`和`setName`⽅法引⽤。所以在下次调⽤`bar.setName`或者`bar.getName`时，创建的执 ⾏上下⽂中就包含了**“clourse(foo)”**。

总结：**产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。**

### 总结

- 介绍了 JavaScript 中的 8 种数据类型，可以分为两大类——**原始类型和引用类型**。
  - 原始类型的数据是放在 **栈** 中，引用类型的数据是存放在 **堆** 中的。堆中的数据是通过引用和变量关联起来的。也就是说JavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。

## 垃圾回收：垃圾数据是如何自动回收的？

有些数据使用之后，可能就不再需要了，我们把这种数据称为 **垃圾数据**。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要 **对这些垃圾数据进行回收，以释放有限的内存空间**。

### 不同语言的垃圾回收策略

通常情况下，垃圾数据回收分为 **手动回收** 和 **自动回收** 两种策略。

如 C/C++ 就是使用手动回收策略，**何时分配内存、何时销毁内存都是由代码控制的**，可以参考如下代码：

```c
//在堆中分配内存 
char* p = (char*)malloc(2048); //在堆空间中分配2048字节的空间，并将分配后的引⽤地址保存到p中 
//使⽤p指向的内存 
{ 
    //.... 
}
//使⽤结束后，销毁这段内存 
free(p)； 
p = NULL；
```

从上⾯这段C代码可以看出来，要使⽤堆中的⼀块空间，我们需要先调⽤ `mallco` 函数分配内存，然后再使⽤；当不再需要这块数据的时候，就要⼿动调⽤ `free` 函数来释放内存。如果这段数据已经不再需要了，但是 ⼜没有主动调⽤ `free` 函数来销毁，那么这种情况就被称为**内存泄漏** 。

另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，**产生的垃圾数据是由垃圾回收器来释放的**，并不需要手动通过代码来释放。

### 调用栈中的数据是如何回收的

例子代码如下：

```js
function foo() {
    var a = 1;
    var b = { name: "极客邦" };
    function showName() {
        var c = "极客时间";
        var d = { name: "极客时间" };
    }
    showName();
}
foo();
```

当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：

![1644687559810](assets/1644687559810.png)

从图中可以看出，原始类型的数据被分配到栈中，引⽤类型的数据会被分配到堆中。当 `foo` 函数执⾏结束之 后，`foo` 函数的执⾏上下⽂会从堆中被销毁掉，那么它是怎么被销毁的呢？下⾯我们就来分析⼀下。

之前简单介绍过，如果执行到 `showName` 函数时，那么 JavaScript 引擎会创建 `showName` 函数的执行上下文，并将 `showName` 函数的执行上下文压入到调用栈中，最终执行到 `showName` 函数时，其调用栈就如上图所示。与此同时，还有一个 **记录当前执行状态的指针（称为 ESP）**，指向调用栈中 `showName` 函数的执行上下文，表示当前正在执行 `showName` 函数。

接着，当 `showName` 函数执行完成之后，函数执行流程就进入了 `foo` 函数，那这时就需要销毁 `showName` 函数的执行上下文。**ESP** 这时候就帮上忙了，JavaScript 会将 **ESP** 下移到 `foo` 函数的执行上下文，**这个下移操作就是销毁 showName 函数执行上下文的过程。**

具体可以看下⾯这张移动 **ESP** 前后的对⽐图： 

![1644688066788](assets/1644688066788.png)

从图中可以看出，当 `showName` 函数执行结束之后，**ESP** 向下移动到 `foo` 函数的执行上下文中，上面 `showName` 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 `foo` 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另一个函数的执行上下文。

所以说，当一个函数执行结束之后，**JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文**。

### 堆中的数据是如何回收的

通过上文的讲解，知道当 `foo` 函数执行结束之后，**ESP** 应该是指向全局执行上下文的，这样的话，`showName` 函数和 `foo` 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：

![1644764372235](assets/1644764372235.png)